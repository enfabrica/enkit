load("//bazel/enkit:defs.bzl", "multirun")
load("@bazel_gazelle//:def.bzl", "gazelle")
load("@com_github_bazelbuild_buildtools//buildifier:def.bzl", "buildifier")
load("@rules_python//python/pip_install:requirements.bzl", "compile_pip_requirements")

# To update and generate the BUILD.bazel files, run:
#     bazelisk run //:gazelle
#
# This will scan the source code, and bazed on imports, generate
# or update the BUILD.bazel files. Run every time you change imports,
# create a new library or binary.
#
# To update the list of dependencies downloaded by bazel, run:
#     bazelisk run //:gazelle_update_repos
#
# This will read the go.mod file, and based on that, add statements
# to download the correct dependency for bazel to download. The dependency
# is added to the bazel/go_repositories.bzl file.
#

# Set the prefix for this repo
# gazelle:prefix github.com/enfabrica/enkit

# Ensure that BUILD files have targets generated with the correct convention
# TODO(scott): Change to `import` after targets have migrated to use the new
# convention
# gazelle:go_naming_convention import_alias
gazelle(
    name = "gazelle",
    prefix = "github.com/enfabrica/enkit",
)

gazelle(
    name = "gazelle_update_repos",
    args = [
        "-from_file=go.mod",
        "-to_macro=bazel/go_repositories.bzl%go_repositories",
        "-prune",
    ],
    command = "update-repos",
)

# Custom gazelle resolve mappings
# Some third-party dependencies that are bazel-aware bamboozle gazelle running
# in our repository, which tries to generate dependency labels that don't exist.
# These mappings keep gazelle from generating bogus dependency labels.
#
# gazelle:resolve go kythe.io/kythe/go/platform/delimited @io_kythe//kythe/go/platform/delimited

# gazelle:resolve go github.com/enfabrica/enkit/auth/server/assets/templates //auth/server/assets/templates

exports_files(
    [
        "go.mod",
        "go.sum",
    ],
    visibility = ["//:__subpackages__"],
)

# To automatically format all .bzl files and all BUILD.bzl files, run:
#     bazelisk run //:buildifier
buildifier(
    name = "buildifier",
)

multirun(
    name = "binaries_release",
    commands = [
        "//enkit:deploy",
        "//staco:deploy",
        "//faketree:astore_push",
        "//flextape/server:astore_push",
        # TODO(scott): Move the main to //flextape/client, delete this dir
        "//manager/client:astore_push",
    ],
)

compile_pip_requirements(
    name = "python_deps",
    requirements_in = "requirements.in",
    requirements_txt = "requirements.txt",
)
