#!/bin/bash

read -r -d '' USAGE <<'EOT'
. __ _  ___  ___ 
 / _` |/ _ \/ _ \  git
| (_| |  __/  __/  enabled
 \__, |\___|\___|  enfabrication
 |___/           

gee version: {{VERSION}}

gee is a wrapper around the "git" and "gh-cli" tools.  "gee" captures all
tribal knowledge about how to use git the right way (for us), implementing one
standard and well-supported workflow.  "gee" is also an instructional tool: by
showing each command as it executes, gee helps users learn git.

## Features:

* Uses the "worktree" feature so that:
   * every branch is always visible in its own directory.
   * switching branches is accomplished by changing directory.
   * it's harder to accidentally save changes to the wrong branch.
   * users can have uncommitted changes pending in more than one branch.
  All branch directories are named ~/gee/<REPO>/<BRANCH>.

* All local commits are automatically backed up to github.

* Tracks lineage of branches-of-branches.

* Sets up and enforces use of ssh for all interactions with github.

* Supports multi-homed development (user can do work on various hosts without
  NFS-mounted home directories).

## An example of simple use:

1. Run "gee init" to clone and check out the enfabrica/internal repo.  This
   only needs to be done once per home directory.

2. "cd ~/gee/internal/main" to start in the main branch.

3. Make a feature branch: "gee make_branch my_feature"
   Then: "cd $(gee gcd my_feature)"

4. Make some changes, and call "gee commit" whenever needed to checkpoint
   your work.

5. Call "gee update" to pull new changes from upstream.

6. When ready to send your change out for review:

    gee fix  # runs all automatic code formatters
    gee commit -a -m "ran gee fix"
    gee make_pr  # creates a pull request.

7. You can continue to make updates to your branch, and update your
   PR by running "gee commit".

8. When approved, run "gee submit_pr" to merge your change.

## An example of more complex use:

You can continue to develop a second feature while the first feature is out for
review.

1. Make a branch of a branch:

     cd $(gee gcd my_feature)
     gee mkbr my_feature2

3. Do work in the child branch:

     cd $(gee gcd my_feature2)

2. Recursively update a chain of branches:

     gee rupdate

EOT
# Philosophy:
#
#    If I have to look it up on stack overflow, it should get encoded in gee.
#    Automatic but not automagic.  No surprises.  Show your work.  Never change
#    the system in a way the user doesn't expect.  When in doubt, ask.
#
#    Do what I mean: I'm lysdexic, so a lot of the commands have reverse order
#    aliases.
#
# Branches:
#    upstream: the original repo we have forked (enfabrica/$REPO)
#              we issue pull requests to this repo, and we integrate
#              changes from here.
#    origin:   the user's forked repo ($GHUSER/$REPO)
#              we pull and push to this repo.
#    upstream/main: top of tree
#    origin/main: user's top-of-tree with no local changes,
#        updated periodically from upstream/main.
#    main: local repo top of tree, no local changes,
#        updated periodically from upstream/main.
#    $feature: fork of main (or other $feature), contains
#        local changes.  May have 0 or 1 PRs associated with it.
#    origin/$feature: github backup of $feature branch.
# 
# Updates flow in one direction through these branches:
# 
#   upstream/main -> main -> origin/main -> $feature -> origin/$feature
# 
# The user only commits changes to $feature.
# 
# Changes then migrate from origin/$feature back to upstream/main when a PR is
# approved and merged.
# 
# Note: We are transitioning from "master" to "main."  Gee always tries to find
# a "main" remote branch first, but falls back to "master" if "main" does not
# exist.
#
# TODO(jonathan): Bash implementation is a prototype.  rewrite in golang?
# TODO(jonathan): "git push -u" option is going to change soon.

set -e

if [[ -n "${DEBUG}" ]]; then
  set -x
fi

function _fix_pwd() {
  # Make sure we're in a real directory.
  #
  # Sometimes funny things happen with git and directories:
  #  - git rebase can re-create a directory, changing the inode and leaving pwd
  #    invalid.
  #  - removing a worktree can leave the pwd in an invalid directory.
  #
  # Let's make sure we're in a directory that exists:
  local PIFS="${IFS}"
  local D="${PWD}"
  cd /
  local p
  IFS="/"; for p in ${D}; do
    if [[ -n "$p" && -d "$p" ]]; then
      cd "$p"
    fi
  done
  IFS="${PIFS}"
}
_fix_pwd

# Globals:
readonly VERSION="0.1"
declare -a HELP=()
declare -A LONGHELP
declare -A PARENTS     # initialized by _load_parents_file
declare -A MERGEBASES  # initialized by _load_parents_file
declare -A BRANCH_TO_WORKTREE=()
readonly TRUE=0
readonly FALSE=1
readonly GIT=/usr/bin/git
readonly GH=/usr/bin/gh
readonly JQ=/usr/bin/jq
readonly SSHKEYFILE="${HOME}/.ssh/gee_github_ed25519"
readonly ENKIT=/opt/enfabrica/bin/enkit
readonly GIT_AT_GITHUB="org-64667743@github.com"
readonly NEWLINE=$'\n'
readonly CLONE_DEPTH=3  # a little bit of history
GHUSER="${GHUSER:-}"  # can be set by _startup_checks
VERBOSE="${VERBOSE:-1}"
DRYRUN="${DRYRUN:-0}"
UPSTREAM="${UPSTREAM:-enfabrica}"
TESTMODE="${TESTMODE:-0}"
MAIN="" # Unknown, call _set_main to set.
REPO="${REPO:-}"
PAGER="${PAGER:-less}"
PARENTS_FILE_IS_LOADED=0
PWD_CMD="$(command -v pwd)"  # dev: /usr/bin/pwd, fpga-dev: /bin/pwd  :-(
declare -A FLAGS=()  # for _parse_options(), below
declare -a ARGS_POSITIONAL=()  # for _parse_options(), below

# Make sure we're in a directory that exists:
while ! "${PWD_CMD}" >/dev/null; do
  cd ..
done

if [[ -z "${REPO}" ]]; then
  # Examine the directory to see if we're in a repo already.
  # Try the old directory layout:
  if [[ "${PWD}" =~ ^${HOME}/([a-z0-9_-]+)/branches ]]; then
    REPO="${BASH_REMATCH[1]}"
  fi
  # Try the new directory layout:
  if [[ "${PWD}" =~ ^${HOME}/gee/([a-z0-9_-]+) ]]; then
    REPO="${BASH_REMATCH[1]}"
  fi
  # Try the test directory layout:
  if [[ "${PWD}" =~ ^${HOME}/testgee/([a-z0-9_-]+) ]]; then
    TESTMODE=1
    REPO="${BASH_REMATCH[1]}"
  fi
fi

# If all else fails, default to internal
if [[ -z "${REPO}" ]]; then
  REPO=internal
fi

GEE_DIR="${HOME}/gee"
REPO_DIR="${GEE_DIR}/${REPO}/"

if (( "${TESTMODE}" )); then
  UPSTREAM="enfabrica"
  REPO="github-playground"
  GEE_DIR="${HOME}/testgee"
  REPO_DIR="${GEE_DIR}/${REPO}/"
fi

# colors library
_COLOR_RST="$(tput sgr0)"
_COLOR_CMD="$(tput bold; tput setaf 12; tput rev)"
_COLOR_BANNER="$(tput bold; tput setab 21; tput setaf 15)"
#_COLOR_CMD="$(tput bold; tput setaf 14; tput setab 16)"
_COLOR_DBG="$(tput setaf 2)"
_COLOR_DIE="$(tput bold; tput setaf 15; tput setab 3)"
_COLOR_WARN="$(tput setaf 11)"
_COLOR_INFO="$(tput setaf 1)"

##########################################################################
# utility functions
# 
# (the good stuff, the commands, are in the next section below.)
##########################################################################

function _parse_options() {
  # _parse_options <optstring> <args...>
  #
  # This function populates the global FLAGS associative array with all
  # of the set flags.  Any remaining positional arguments are left behind
  # in the ARGS_POSITIONAL array
  export FLAGS=()
  export ARGS_POSITIONAL=()
  local optstring="$1"; shift
  local arg
  OPTERR=0  # enable silent error reporting
  while [[ $# -gt 0 ]]; do
    unset OPTARG
    unset OPTIND
    while getopts "${optstring}" arg; do
      if [[ "${arg}" == "?" ]]; then
        local x
        x=$((OPTIND-1))
        _fatal "Bad command flag: ${!x}"
      fi
      FLAGS["${arg}"]="${OPTARG:-1}"
    done
    shift $((OPTIND-1))
    if [[ $# -gt 0 ]]; then
      ARGS_POSITIONAL+=( "$1" )
      shift
    fi
  done
  return 0
}

function __git_eread () {
  # Used by _gee_rebase_prompt
	test -r "$1" && IFS=$'\r\n' read -r "$2" <"$1"
}

# This function might be improved in the future for users to use as a
# bash COMMAND_PROMPT command, but needs improvements.
function gee__prompt() {
  _gee_rebase_prompt
}

function _gee_rebase_prompt() {
  # Prompt to be used while in an interactive conflict resolution shell.
  # cribbed from git-prompt.sh
	# preserve exit status
	local exit=$?
	local detached=no

	local repo_info rev_parse_exit_code
	repo_info="$(git rev-parse \
    --git-dir \
    --is-inside-git-dir \
		--short HEAD 2>/dev/null)"
	rev_parse_exit_code="$?"

	if [ -z "$repo_info" ]; then
		return $exit
	fi

	local short_sha=""
	if [ "$rev_parse_exit_code" = "0" ]; then
		short_sha="${repo_info##*$'\n'}"
		repo_info="${repo_info%$'\n'*}"
	fi
	local inside_gitdir="${repo_info##*$'\n'}"
	local g="${repo_info%$'\n'*}"

	if [ "true" = "$inside_gitdir" ] &&
	   [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] &&
	   [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] &&
	   git check-ignore -q .
	then
		return $exit
	fi

	local r=""
	local b=""
	local step=""
	local total=""
	if [ -d "$g/rebase-merge" ]; then
		__git_eread "$g/rebase-merge/head-name" b
		__git_eread "$g/rebase-merge/msgnum" step
		__git_eread "$g/rebase-merge/end" total
		r="|REBASE"
	else
		if [ -d "$g/rebase-apply" ]; then
			__git_eread "$g/rebase-apply/next" step
			__git_eread "$g/rebase-apply/last" total
			if [ -f "$g/rebase-apply/rebasing" ]; then
				__git_eread "$g/rebase-apply/head-name" b
				r="|REBASE"
			elif [ -f "$g/rebase-apply/applying" ]; then
				r="|AM"
			else
				r="|AM/REBASE"
			fi
		elif [ -f "$g/MERGE_HEAD" ]; then
			r="|MERGING"
		elif [ -f "$g/BISECT_LOG" ]; then
			r="|BISECTING"
		fi

		if [ -n "$b" ]; then
			:
		elif [ -h "$g/HEAD" ]; then
			# symlink symbolic ref
			b="$(git symbolic-ref HEAD 2>/dev/null)"
		else
			local head=""
			if ! __git_eread "$g/HEAD" head; then
				return $exit
			fi
			# is it a symbolic ref?
			b="${head#ref: }"
			if [ "$head" = "$b" ]; then
				detached=yes
				b="$( git describe --tags --exact-match HEAD 2>/dev/null)" ||
				b="$short_sha..."
				b="($b)"
			fi
		fi
	fi

	if [ -n "$step" ] && [ -n "$total" ]; then
    r="$r ($step/$total)"
	fi

	b=${b##refs/heads/}

  local d
  d="$("${PWD_CMD}")"

  local COLOR RST
  COLOR="$(tput bold; tput rev)"
  RST="$(tput sgr0)"
  if [[ -n "${GEE_HELP}" ]]; then
    printf "%s\n" "${GEE_HELP}"
  fi
  printf -- "${COLOR}%s%s%s %s${RST}\n$ " "${GEE_STATUS}" "${b}" "${r}" "${d}"

	return $exit
}

function _contains_element() {
  # Returns true if the first argument is present in one of the subsequent
  # arguements.
  local MATCH="$1"
  shift
  local E
  for E in "$@"; do
    if [[ "$E" == "${MATCH}" ]]; then
      return 0
    fi
  done
  return 1
}

function _egrep_array() {
  # Usage: _egrep_array <output> <regex> <elements...>
  #
  # Filters a list of elements by a regex, and stores an array of those
  # filtered elements into the specified "output" variable.
  local OUTPUT="$1"
  local REGEX="$2"
  unset "${OUTPUT}"
  declare -a "${OUTPUT}"
  readarray -t "${OUTPUT}" < <( printf "%s\n" "$@" | grep -E "${REGEX}" )
}

function _set_alias_if_missing() {
  # Creates a git alias, only if one does not already exist.
  local ALIAS="$1"
  local DEFN="$2"
  if ! "${GIT}" config --get "alias.${ALIAS}" >/dev/null; then
    _git config --global "alias.${ALIAS}" "${DEFN}"
  fi
}

function _set_main_by_asking_github() {
  _check_ssh
  local UPSTREAM_URL
  UPSTREAM_URL="${GIT_AT_GITHUB}:${UPSTREAM}/${REPO}.git"
  MAIN="$(
    "${GIT}" remote show "${UPSTREAM_URL}" \
      | awk '/HEAD branch/ {print $NF}'
  )"
  if [[ -z "${MAIN}" ]]; then
    _die "Can't identify default branch for ${UPSTREAM_URL}."
  fi
}

function _set_main() {
  # Sets the ${MAIN} global variable to be the name of the main branch of the
  # current repository.  Usually "main" or "master," but not always.

  # Use a cached result if available:
  if [[ -n "${MAIN}" ]]; then return; fi

  # If a master or main branch exist on our local file system, assume:
  if [[ -d "${REPO_DIR}/master" ]]; then
    MAIN=master
    return
  elif [[ -d "${REPO_DIR}/main" ]]; then
    MAIN=main
    return
  fi

  # Ok, let's ask github:
  _set_main_by_asking_github
}

function _set_ghuser() {
  # Attempts to ensure that the GHUSER environment variable is set correctly.
  # If GHUSER is unset, _set_ghuser first tries to get the username from
  # github.  Failing that, the default username of $(whoami)-enf is set.
  if [[ -n "${GHUSER}" ]]; then
    return 0
  fi

  # try to get ghuser from ssh interface:
  local OUTPUT
  set +e
  OUTPUT="$(ssh -T "${GIT_AT_GITHUB}" 2>&1)"
  set -e
  if [[ "${OUTPUT}" =~ ^Hi\ ([a-zA-Z0-9_-]+) ]]; then
    GHUSER="${BASH_REMATCH[1]}"
    return 0
  fi

  # let's just ask the user
  _warn "Can't automatically determine your github username."
  if [[ -z "${USER}" ]]; then
    USER="$(whoami)"
  fi
  if [[ -n "${USER}" ]]; then
    GHUSER="${USER}-enf"
  fi
  read -r -i "${GHUSER}" -p "What is your github username?  " -e GHUSER

  if [[ -z "${GHUSER}" ]]; then
    _fatal "Cannot proceed without a github username."
  fi
  local RESP
  read -r -p \
    "Is it okay to add \"export GHUSER=${GHUSER}\" to your .bashrc file? (y/N)  " \
    RESP
  case "${RESP}" in
    [Yy]*)
      printf "\nexport GHUSER=%q\n" "${GHUSER}" >> ~/.bashrc
      ;;
  esac
}


function _check_ssh_agent() {
  # Check that the ssh-agent is loaded and reachable.
  if [[ -z "${SSH_AGENT_PID}" ]]; then
    _warn "SSH_AGENT_PID is not set."
    _info "Consider adding \"eval \`enkit agent print\`\" to your .bashrc"
    local RESP
    read -r -p \
      "Would you like gee to append this line to your .bashrc file now? (y/N)  "\
      RESP
    case "${RESP}" in
      [Yy]*)
        printf "eval \`enkit agent print\`\n" >> ~/.bashrc
        ;;
    esac
    eval "$(enkit agent print)"
    if [[ -z "${SSH_AGENT_PID}" ]]; then
      _fatal "Something is wrong with enkit's ssh agent."
    fi
  fi
  if ! ssh-add -l > /dev/null; then
    local RC=$?
    if (( RC == 2 )); then
      _fatal "Unable to communicate with enkit's ssh agent."
    fi
  fi
}

function _check_enkit_cert() {
  # Check if we have a valid enkit authentication token.
  local COUNT
  COUNT="$("${ENKIT}" agent print | wc -l)"
  if (( COUNT == 0 )); then
    _warn "enkit certificate is expired."
    _info "Please authenticate:"
    "${ENKIT}" login
    COUNT="$("${ENKIT}" agent print | wc -l)"
    if (( COUNT == 0 )); then
      _fatal "No enkit certificate, aborting."
    fi
  fi
  COUNT="$(ssh-add -l | wc -l)"
  if (( COUNT == 0 )); then
    _fatal "enkit's certificate isn't showing up in ssh-agent."
  fi
}

function _check_ssh() {
  # Troubleshoot ssh connection to github.

  # First check if we have an ssh-agent running:
  _check_ssh_agent

  # Check that the enkit certification is available
  _check_enkit_cert

  # Check if we can connect via ssh to github.
  # Takes 0.7 seconds.  Use only as-needed.
  local OUTPUT
  set +e
  OUTPUT="$(ssh -T "${GIT_AT_GITHUB}" 2>&1)"
  set -e
  if [[ "${OUTPUT}" =~ ^Hi\ ([a-zA-Z0-9_-]+) ]]; then
    GHUSER="${BASH_REMATCH[1]}"
    return 0
  fi
  _warn "Could not authenticate to github using ssh."
  _info "ssh -T \"${GIT_AT_GITHUB}\" got:"
  _info "  ${OUTPUT}"

  if [[ -f "${SSHKEYFILE}" ]]; then
    _info "Perhaps you need to run: ssh-add ${SSHKEYFILE}"
    _cmd ssh-add "${SSHKEYFILE}"
    _info "Trying again..."
    set +e
    OUTPUT="$(ssh -T ${GIT_AT_GITHUB} 2>&1)"
    set -e
    if [[ "${OUTPUT}" =~ ^Hi\ ([a-zA-Z0-9_-]+) ]]; then
      GHUSER="${BASH_REMATCH[1]}"
      return 0
    fi
    _warn "Still couldn't authenticate to github using ssh."
    _info "ssh -T ${GIT_AT_GITHUB} got:"
    _info "  ${OUTPUT}"
  fi
  return 1
}

function _check_gh_auth() {
  # Check that the gh-cli tool has a valid access token for
  # communicating with github.
  local OUTPUT RC

  set +e
  OUTPUT="$("${GH}" auth status 2>&1)";
  RC=$?
  set -e
  if (( RC != 0 )); then
    _info "Could not authenticate to github.  Got:" "${OUTPUT}"
    _info "Let's try refreshing your access token:"
    _cmd "${GH}" auth login
    if ! "${GH}" auth status; then
      _fatal "Still can't authenticate to github."
    fi
  fi
}


function _check_cwd() {
  # Check that we're in a directory beneath ~/gee.
  local DIR
  DIR="$("${PWD_CMD}")"
  if ! [[ "$DIR" =~ ^"${GEE_DIR}"/[a-zA-Z0-9_-]+ ]]; then
    echo "${DIR}"
    _fatal "This command must be run from with a branch directory beneath ~/gee."
  fi
}

function _get_ghuser_via_ssh() {
  # Set GHUSER or die.
  if ! _check_ssh; then
    _fatal "Could not determine github username."
  fi
}

function _startup_checks() {
  # Troubleshoot our environment before running (most) commands.
  if [[ ! -x "${GIT}" ]]; then
    _fatal "${GIT} is not installed."
  fi
  if [[ ! -x "${GH}" ]]; then
    _fatal "${GH} is not installed."
  fi

  # If GHUSER is unset, find username via ssh to github.
  if [[ -z "${GHUSER}" ]]; then
    _set_ghuser
  fi

  local GIT_EMAIL
  GIT_EMAIL="$("${GIT}" config --get user.email || /bin/true)"
  if [[ -z "${GIT_EMAIL}" ]]; then
    _warn "git user.email setting is empty."
    read -e -r -i "${USER}@enfabrica.net" -p \
      "What email address should git use for you?   " \
      GIT_EMAIL
    if [[ -z "${GIT_EMAIL}" ]]; then
      _fatal "git needs user.email to be set."
    fi
    _git config --global user.email "${GIT_EMAIL}"
  fi

  local GIT_NAME
  GIT_NAME="$("${GIT}" config --get user.name || /bin/true)"
  if [[ -z "${GIT_NAME}" ]]; then
    _warn "git user.name setting is empty."
    read -e -r -i "${USER}" -p \
      "What name should git use for you?   " \
      GIT_NAME
    if [[ -z "${GIT_NAME}" ]]; then
      _fatal "git needs user.name to be set."
    fi
    _git config --global user.name "${GIT_NAME}"
  fi

  # check ssh agent
  local RC
  set +e
  ssh-add -l >/dev/null
  RC=$?
  set -e
  if (( RC == 0 )); then
    return 0
  elif (( RC == 1 )); then
    if [[ -f "${SSHKEYFILE}" ]]; then
      _cmd ssh-add "${SSHKEYFILE}"
    fi
  elif (( RC == 2 )); then
    _warn "Could not connect to ssh-agent."
    _info "Consider adding \"eval \`enkit agent print\`\" to your .bashrc"
    local RESP
    read -r -p \
      "Would you like gee to append this line to your .bashrc file now? (y/N)  "\
      RESP
    case "${RESP}" in
      [Yy]*)
        printf "eval \`enkit agent print\`\n" >> ~/.bashrc
        ;;
    esac
    eval "$(enkit agent print)"
  fi
  
  set +e
  ssh-add -l >/dev/null
  RC=$?
  set -e
  if (( RC == 1 )); then
    _fatal "ssh-agent doesn't report any keys.  Please \"enkit login\" and try again."
  elif (( RC == 2 )); then
    _fatal "Persistent failure connecting to ssh-agent."
  elif (( RC != 0 )); then
    _fatal "Unknown error from ssh-add command: RC=${RC}"
  fi
}

function _ssh_enroll() {
  # Enroll the user for ssh access to github by creating and uploading a keyfile.
  if [[ -z "${SSH_AUTH_SOCK}" ]]; then
    _warn "No ssh-agent is running."
    _info "Please add \"eval \`enkit agent print\`\" to your .bashrc"
    local RESP
    read -r -p \
      "Would you like gee to append this line to your .bashrc file now? (y/N)  "\
      RESP
    case "${RESP}" in
      [Yy]*)
        printf "eval \`enkit agent print\`\n" >> ~/.bashrc
        ;;
    esac
    eval "$(enkit agent print)"
  fi
  if [[ -z "${SSH_AUTH_SOCK}" ]]; then
    _fatal "gee requires ssh-agent to be running.  Fix and retry."
  fi

  if [[ ! -f "${SSHKEYFILE}" ]]; then
    _cmd ssh-keygen -f "${SSHKEYFILE}" -t ed25519 -C "${USER}@enfabrica.net"
  else
    _info "Reusing existing ${SSHKEYFILE}"
  fi
  if [[ ! -f "${SSHKEYFILE}" ]]; then
    _fatal "Key file ${SSHKEYFILE} was not created."
  fi

  local COUNT
  COUNT="$("${ENKIT}" agent list | wc -l)"
  if (( COUNT == 0 )); then
    _warn "No enkit certificates are present."
    _info "Let's try authenticating:"
    "${ENKIT}" auth
    COUNT="$("${ENKIT}" agent list | wc -l)"
    if (( COUNT == 0 )); then
      _die "Still could not find any enkit certificates."
    fi
  fi

  local COUNT
  COUNT="$("${ENKIT}" agent list | wc -l)"
  if (( COUNT == 0 )); then
    _warn "No enkit certificates are present."
    _info "Let's try authenticating:"
    "${ENKIT}" auth
    COUNT="$("${ENKIT}" agent list | wc -l)"
    if (( COUNT == 0 )); then
      _die "Still could not find any enkit certificates."
    fi
  fi

  # TODO(jonathan): Is this necessary?
  cat <<EOT >> ~/.ssh/config
# gee: block start
Host *.github.com
  IdentityFile ${SSHKEYFILE}
# gee: block stop
EOT

  _cmd ssh-add "${SSHKEYFILE}"
  _gh config set git_protocol ssh


  # Override BROWSER because xdg-open opens links2 on some systems, and
  # links2 doesn't support github.
  BROWSER="bash -c \"echo Open this URL: \$*\" --" \
    _gh auth login
  # The user might have to open their web browser at this point:
  read -n1 -rsp $'Press any key to continue, or Control-C to exit.\n'

  _gh ssh-key add "${SSHKEYFILE}.pub" --title "gee-created-key"

  _gh ssh-key list

  # Override BROWSER because xdg-open opens links2 on some systems, and
  # links2 doesn't support github.
  BROWSER="bash -c \"echo Open this URL: \$*\" --" \
    _gh auth login
  # The user might have to open their web browser at this point:
  read -n1 -rsp $'Press any key to continue, or Control-C to exit.\n'

  _gh ssh-key add "${SSHKEYFILE}.pub" --title "gee-created-key"

  _gh ssh-key list

  if ! _check_ssh; then
    _fatal "Something still wrong: can't authenticate to github via ssh."
  fi
}

function _register_help() {
  # Registers help text about a gee command.
  #
  # Usage: _register_help <command> <shorthelp> <aliases...>
  #
  # The "long help" for this command must be presented to this
  # function as stdin.
  local COMMAND SHORT LONG ALIAS
  COMMAND="$1"
  shift
  SHORT="$1"
  shift
  LONG="$(</dev/stdin)"
  HELP+=( "${COMMAND}: ${SHORT}" )
  local -a ALIASES
  ALIASES=("$@")
  if (( "${#ALIASES[@]}" > 0 )); then
    LONG="Aliases: ${ALIASES[*]}${NEWLINE}${LONG}"
  fi
  LONGHELP+=(["${COMMAND}"]="${LONG}")
  for ALIAS in "${ALIASES[@]}"; do
    LONGHELP+=(["${ALIAS}"]="${LONG}")
  done
}

function _get_parent_branch() {
  # Return the name of the branch that is the parent of this
  # branch.
  local BRANCH
  BRANCH="$1"
  if [[ -z "${BRANCH}" ]]; then
    BRANCH="$(_get_current_branch)"
  fi

  _read_parents_file
  # BRANCH should be in the parents file.  Let's check there first:
  if [[ -v PARENTS["${BRANCH}"] ]]; then
    echo "${PARENTS[$BRANCH]}"
    return
  fi
  _warn "Strangely, ${BRANCH} was missing from ${REPO_DIR}/.gee/parents."

  # This shouldn't happen, but if it does, we can still make a pretty
  # good guess by looking for the closest other branch:
  local PARENT
  PARENT="$(git show-branch | sed "s/].*//" | grep "\*" \
    | grep -v "${BRANCH}" | head -n1 \
    | perl -pe 'm/\[(.*?)(\^\d+)?(~\d+)?$/; $_ = $1;')"
  if [[ -n "${PARENT}" ]]; then
    echo "${PARENT}"
    return
  fi
  _warn "Strangely, show-branch could identify a parent for ${BRANCH}."

  # Nothing worked!  Default to "${MAIN}".
  _set_main
  echo "${MAIN}"
}

function _update_branch_to_worktree() {
  # Initialize the global BRANCH_TO_WORKTREE associative array with
  # a mapping of branch names onto worktree paths.
  BRANCH_TO_WORKTREE=()  # global
  local LINE WT BR
  _set_main
  while IFS="" read -r LINE; do
    if [[ "${LINE}" =~ ^worktree\ (.+) ]]; then
      WT="${BASH_REMATCH[1]}"
    elif [[ "${LINE}" =~ ^branch\ refs/heads/(.+) ]]; then
      BR="${BASH_REMATCH[1]}"
    elif [[ "${LINE}" == "" ]]; then
      if [[ -n "${BR}" ]]; then
        BRANCH_TO_WORKTREE["${BR}"]="${WT}"
      fi
    fi
  done < <(cd "${GEE_DIR}/${REPO}/${MAIN}"; "${GIT}" worktree list --porcelain )
}

function _get_branch_rootdir() {
  # Return the root directory of a git branch
  local BRANCH_NAME BRDIR
  BRANCH_NAME="$1"
  if [[ -z "${BRANCH_NAME}" ]]; then
	  BRANCH_NAME="$(_get_current_branch)"
  fi
  _update_branch_to_worktree
  BRDIR="${BRANCH_TO_WORKTREE["${BRANCH_NAME}"]}"
  if [[ -z "${BRDIR}" ]]; then
    _die "_get_branch_rootdir failed for ${BRANCH_NAME}"
  fi
  echo "${BRDIR}"
}

function _confirm_default_yes() {
  # Ask the user for confirmation, defaulting to "yes."
  # Returns true if the user confirms.
  local _PROMPT RESP
  _PROMPT="$*"
  if [[ -z "${_PROMPT}" ]]; then
    _PROMPT="Confirm? (y/N)  "
  fi
  read -rp "${_PROMPT}" RESP
  case "${RESP}" in
    [Nn]*) return 1 ;;
    *)     return 0 ;;
  esac
}

function _confirm_default_no() {
  # Ask the user for confirmation, defaulting to "no."
  # Returns true if the user confirms.
  local _PROMPT RESP
  _PROMPT="$*"
  if [[ -z "${_PROMPT}" ]]; then
    _PROMPT="Confirm? (y/N)  "
  fi
  read -rp "${_PROMPT}" RESP
  case "${RESP}" in
    [Yy]*) return 0 ;;
    *)     return 1 ;;
  esac
}

function _confirm_or_exit() {
  # Ask the user for confirmation, defaulting to "no."
  # Terminates gee if the user does not confirm.
  if ! _confirm_default_no "$@"; then
    _fatal "Exiting."
  fi
}

# "The developer wants to read this."
function _debug() {
  if (( "${DEBUG:-0}" > 0 )); then
    printf >&2 "${_COLOR_DBG}DBG: %s${_COLOR_RST}\n" "$@"
  fi
}

# "The user wants to read this."
function _info() {
  printf >&2 "${_COLOR_INFO}%s${_COLOR_RST}\n" "$@"
}

# "The user needs this to visually separate information."
function _banner() {
  local COLS LEN BAR BLANK
  COLS="$(tput cols)"
  COLS="$(( COLS - 1 ))"
  LEN="$( printf "%s\n" "$@" | wc -L )"
  if (( LEN > (COLS-4) )); then
    LEN="$(( COLS - 4 ))"
  fi
  BAR="$(head -c "$(( LEN + 4 ))" /dev/zero | tr '\0' '#')"
  BLANK="$(head -c "$(( COLS - LEN - 4 ))" /dev/zero | tr '\0' ' ')"
  printf "\n" >&2
  printf "%s%s%s\n" "${_COLOR_BANNER}" "${BAR}" "${BLANK}" >&2
  printf "# %-${LEN}.${LEN}s #${BLANK}\n" "$@" >&2
  printf "%s%s%s\n" "${BAR}" "${BLANK}" "${_COLOR_RST}" >&2
}


# Warn the user.  "The user should know this."
function _warn() {
  printf >&2 "${_COLOR_WARN}WARNING: %s${_COLOR_RST}\n" "$@"
}

# Use _fatal for user errors that don't require a stack dump.
# "The user is going to be sad when they see this."
function _fatal() {
  printf >&2 "${_COLOR_DIE}FATAL: %s${_COLOR_RST}\n" "$@"
  ABNORMAL=0  # we died intentionally.
  exit 1
}

# Use _die to report internal errors that require a stack dump.
# "The user is going to be mad when they see this."
function _die() {
  printf >&2 "${_COLOR_DIE}FATAL: %s${_COLOR_RST}\n" "$@"
  if [[ -z "${NOSTACK}" ]]; then
    echo >&2 "Stack trace:"
    local i
    i=0
    while caller "${i}"; do
      (( i++ ))
    done
  fi
  printf >&2 "Please notify: jonathan@enfabrica.net\n"
  exit 1
}

function _cmd() {
  # Run a command and generate associated log messages.
  local COLS ESCAPED_CMD
  COLS="$(tput cols)"
  ESCAPED_CMD="$( printf " %q" "$@")"
  if [[ $DRYRUN -eq 0 ]]; then
    if [[ $VERBOSE -gt 0 ]]; then
      local C
      C=$(( COLS - 4 ))
      printf "${_COLOR_CMD}CMD:%-${C}s${_COLOR_RST}\n" "${ESCAPED_CMD}"
    fi
    set +e
    "$@"
    RC=$?
    if [[ "${RC}" -ne 0 ]]; then
      _warn "Command failed with exit code ${RC}"
      if [[ -n "${NOFAIL}" ]]; then
        RC=0
      fi
    fi
    set -e
    return "${RC}"
  else
    local C
    C=$(( COLS - 7 ))
    printf "${_COLOR_CMD}DRYRUN:%-${C}s${_COLOR_RST}\n" "${ESCAPED_CMD}"
  fi
}

function _gh() {
  # Invoke gh
  _cmd "${GH}" "$@"
}

function _git() {
  # Invoke git
  _cmd "${GIT}" "$@"
}

function _silent_cmd() {
  # Run a command and don't write anything to stdout.
  local ESCAPED_CMD
  ESCAPED_CMD="$( printf " %q" "$@")"
  if [[ $DRYRUN -eq 0 ]]; then
    set +e
    "$@" > /dev/null
    RC=$?
    set -e
    if [[ "${RC}" -ne 0 ]]; then
      _info "CMD: ${ESCAPED_CMD}"
      if [[ -z "${NOFAIL}" ]]; then
        _fatal "Command failed with exit code ${RC}"
      else
        _warn "Command failed with exit code ${RC}"
      fi
    fi
    return "${RC}"
  fi
}

function _git_can_fail() {
  # Invoke git, but don't exit if git returns a non-zero exit code.
  NOFAIL=1 _git "$@"
}

function _install_tools() {
  # Checks for and installs any missing tools.

  # If your dev image is missing the github-cli tool, this should install it.
  if [ ! -x "${GH}" ]; then
    _info "Installing missing tool: gh"
    local KRFILE; KRFILE="/usr/share/keyrings/githubcli-archive-keyring.gpg"
    /usr/bin/curl -fsSL \
      https://cli.github.com/packages/githubcli-archive-keyring.gpg \
      | sudo /usr/bin/apt-key --keyring "${KRFILE}" add -
    echo "deb [arch=amd64 signed-by=${KRFILE}] https://cli.github.com/packages stable main" \
      | sudo /usr/bin/tee /etc/apt/sources.list.d/githubcli-archive.list
    sudo /usr/bin/apt update && sudo /usr/bin/apt install gh
    if [ ! -x ${GH} ]; then
      _fatal "Could not install gh."
    fi
  fi

  if [ ! -x "${JQ}" ]; then
    _info "Installing missing tool: jq"
    sudo /usr/bin/apt update && sudo /usr/bin/apt install jq
    if [ ! -x "${JQ}" ]; then
      _fatal "Could not install jq."
    fi
  fi
}

function _count_diffs() {
  # Could the number of files that are different between two branches.
  local BRANCH_A BRANCH_B DIFFS
  BRANCH_A="$1"
  BRANCH_B="$2"
  "${GIT}" diff --name-only "${BRANCH_A}..${BRANCH_B}" | wc -l
}

function _branch_ahead_behind() {
  # Report how many commits this branch is ahead/behind another branch.
  local branch; branch="$1"
  local obr="$2";
  _read_parents_file
  if [[ -z "${obr}" ]]; then
    obr="$(_get_parent_branch "${branch}")"
  fi
  local -a counts
  read -r -a counts < <("${GIT}" rev-list --left-right --count "${branch}...${obr}")
  if (( "${counts[0]}" == 0 )) && (( "${counts[1]}" == 0 )); then
    printf "%-20s: same as %s" "${branch}" "${obr}"
  else
    printf "%-20s: %s ahead, %s behind %s" "${branch}" "${counts[0]}" "${counts[1]}" "${obr}"
  fi
  if _remote_branch_exists origin "${branch}"; then
    counts=()
    read -r -a counts < <("${GIT}" rev-list --left-right --count "${branch}...origin/${branch}")
    if (( counts[1] > 0 )); then
      printf ", %d behind %s" "${counts[1]}" "origin/${branch}"
    fi
  fi
  printf "\n"
}

function _remote_branch_exists() {
  # Returns true if a remote branch exists (on "origin").
  local REPO="$1"; shift  # origin?
  local BRANCH="$1"; shift
  if [[ -z "${BRANCH}" ]]; then
    _die "insufficient args"
  fi
  local OUTPUT
  OUTPUT="$("${GIT}" ls-remote "${REPO}" "${BRANCH}")"
  if [[ -z "${OUTPUT}" ]]; then
    return "${FALSE}"
  else
    return "${TRUE}"
  fi
}

function _local_branch_exists() {
  # Returns true if a local branch exists (even if it's worktree was deleted).
  # Fixes up the worktree if the branch is missing from the worktree.
  local BRANCH="$1"; shift
  _set_main
  if ! "${GIT}" show-ref --verify --quiet "refs/heads/${BRANCH}"; then
    return 1  # false
  fi

  # branch exists, but let's double check that worktree is set up correctly:
  local BRDIR
  BRDIR="${REPO_DIR}/${BRANCH}"
  if ! [[ -d "${BRDIR}" ]]; then
    # try to fix worktree.
    _git worktree add "${REPO_DIR}/${BRANCH}"
    _info "Created ${BRDIR}"
  fi
  _update_branch_to_worktree
  BRDIR="${BRANCH_TO_WORKTREE["${BRANCH}"]}"
  if [[ -n "${BRDIR}" ]]; then
    return 0
  else
    _fatal "Branch ${BRANCH} exists but could not create worktree."
    return 1
  fi
}

function _open_rebase_shell() {
    # Opens an interactive subshell for resolving conflicts during a rebase.
    # This is the "old" flow, and it's a bit messy.
    # TODO(jonathan): make the prompts less noisy.
    export PROMPT_COMMAND="_gee_rebase_prompt"
    local BOLD RST
    BOLD="$(tput bold)"
    RST="$(tput sgr0)"
    export GEE_HELP=""
    GEE_HELP+="You are interactively rebasing a branch with conflicts.${NEWLINE}"
    GEE_HELP+="  To see where conflicts are: ${BOLD}git status${RST}${NEWLINE}"
    GEE_HELP+="  To run a 3-way merge tool: ${BOLD}git mergetool${RST}${NEWLINE}"
    GEE_HELP+="  To mark a file as fixed: ${BOLD}git add <file>${RST}${NEWLINE}"
    GEE_HELP+="  To continue rebase after fixing: ${BOLD}git rebase --continue${RST}${NEWLINE}"
    GEE_HELP+="  To give up and go back to original state: ${BOLD}git rebase --abort${RST}${NEWLINE}"
    GEE_HELP+="  To return to gee: ${BOLD}exit${RST}${NEWLINE}"
    export GEE_STATUS="GEE-REBASE-SUBSHELL: "
    export PS1=""
    export -f __git_eread
    export -f _gee_rebase_prompt
    _git status
    _banner "Entering subshell: resolve conflicts or abort and then exit."
    set +e
    bash --noprofile --norc
    _banner "Subshell terminated with exit code $?."
    set -e
}

function _interactive_conflict_resolution() {
  # The function walks the user through a rebase operation, one conflict at a
  # time, and gives the user the option to use their file, the upstream file,
  # skip the commit, run a mergetool, or abort.
  local PARENT CHILD
  PARENT="$1"
  CHILD="$2"
  if [[ -z "${CHILD}" ]]; then
    _die "Must specify branch name."
  fi
  _info "CHILD=${CHILD}"
  local CHILD_ROOT
  CHILD_ROOT="${BRANCH_TO_WORKTREE["${CHILD}"]}"
  _info "CHILD ROOT=${CHILD_ROOT}"
  cd "${CHILD_ROOT}"
  local ABORT=0
  while _is_rebase_in_progress; do
    local -a STATUS=()
    mapfile -t STATUS < <( "${GIT}" status --porcelain )
    # We're merging onto this commit:
    local ONTO_COMMIT ONTO_DESC
    ONTO_COMMIT="$("${GIT}" rev-parse HEAD)"
    ONTO_DESC="$("${GIT}" show --oneline -s "${ONTO_COMMIT}")"
    # This is the commit we're trying to apply:
    local FROM_COMMIT FROM_DESC
    FROM_COMMIT="$("${GIT}" rev-parse REBASE_HEAD)"
    FROM_DESC="$("${GIT}" show --oneline -s "${FROM_COMMIT}")"

    _banner "Attempting to apply: ${FROM_DESC}" \
            "               onto: ${ONTO_DESC}" \
            "Conflicts in ${#STATUS[@]} files."
    local STATUS_LINE DONE SKIP RESTART
    SKIP=0
    RESTART=0
    for STATUS_LINE in "${STATUS[@]}"; do
      local DECODED_ST ST FILE
      read -r ST FILE <<< "${STATUS_LINE}"
      case "${ST}" in
        # TODO(jonathan): do I have "us" and "them" backwards here?
        DD) DECODED_ST="Both deleted" ;;
        AU) DECODED_ST="Added by us" ;;
        UD) DECODED_ST="Deleted by them" ;;
        UA) DECODED_ST="Added by them" ;;
        DU) DECODED_ST="Deleted by us" ;;
        AA) DECODED_ST="Both added" ;;
        UU) DECODED_ST="Both modified" ;;
        *)  DECODED_ST="Bizarre!" ;;
      esac
      _info "" "${FILE}: ${ST}=${DECODED_ST}"

      DONE=0
      while (( DONE == 0 )); do
        local M RESP
        read -r -n1 -p \
          "Keep (O)ld, (N)ew, (M)erge, (G)ui, (S)hell, (V)iew, s(K)ip, or (A)bort? " \
          RESP
        printf "\n"
        # https://stackoverflow.com/questions/25576415/what-is-the-precise-meaning-of-ours-and-theirs-in-git
        # During a rebase operation:
        # "Ours" = branch being merged into = older version of file.
        # "Theirs" = branch being merged from = newer version of file.
        case "${RESP}" in
          [Nn])
            _info "Keeping newer ${FILE} from ${FROM_DESC}"
            "${GIT}" checkout --theirs "${FILE}"
            DONE=1
            ;;
          [Oo])
            _info "Keeping older ${FILE} from ${ONTO_DESC}"
            "${GIT}" checkout --ours "${FILE}"
            DONE=1
            ;;
          [Mm])
            _git mergetool "${FILE}"
            M="$("${GIT}" diff --check "${FILE}" | grep "conflict marker" | wc -l)"
            if (( M == 0 )); then
              DONE=1
            else
              _warn "${FILE} still contains conflict markers."
            fi
            ;;
          [Gg])
            _git mergetool --gui "${FILE}"
            M="$("${GIT}" diff --check "${FILE}" | grep "conflict marker" | wc -l)"
            if (( M == 0 )); then
              DONE=1
            else
              _warn "${FILE} still contains conflict markers."
            fi
            ;;
          [Ss])
            _open_rebase_shell
            RESTART=1  # go back to beginning, maybe we're done?
            DONE=1
            ;;
          [Vv])
            _git rebase --show-current_patch | "${PAGER:-less}"
            ;;
          [Kk])
            _info "Skipping commit: ${FROM_DESC}"
            DONE=1
            SKIP=1
            ;;
          [Aa])
            _info "Aborting rebase, and resetting."
            DONE=1
            ABORT=1
            ;;
          *)
            _error "Invalid choice: ${RESP}"
            _info \
              "Options are:" \
              "  n: Keep (N)ewer file (from the patch being applied)." \
              "  o: Keep (O)lder file (from the version being patched)." \
              "  m: (M)erge: Runs \"git mergetool\" on this file." \
              "  g: (G)UI Merge: Runs \"git mergetool --gui\" on this file." \
              "  s: (S)hell: Opens a bash sub-shell for expert use." \
              "  v: (V)iew: Show the patch being applied." \
              "  k: s(K)ip: Skips a whole commit (all files)." \
              "  a: (A)bort: Aborts and returns branch to original state."
            ;;
        esac
      done  # DONE

      if (( SKIP == 1 )); then break; fi
      if (( ABORT == 1 )); then break; fi
      if (( RESTART == 1 )); then break; fi
    done  # STATUS_LINE

    if (( SKIP == 1 )); then
      _git rebase --skip
      break
    fi
    if (( ABORT == 1 )); then break; fi
    if (( RESTART == 1 )); then continue; fi

    local -a MARKERS
    mapfile -t MARKERS < <( "${GIT}" diff --check | grep "conflict marker" )

    if (( "${#MARKERS[@]}" == 0 )); then
      _git add .
      _git_can_fail rebase --continue
    else
      _warn "Cannot proceed with rebase: conflict markers still present."
      _info "${MARKERS[@]}"
      _info "Try again..."
    fi
  done  # while rebase is in progress

  if (( ABORT == 1 )); then
    _git rebase --abort
    return
  fi
}

function _rebase_child_onto_parent() {
  # It turns out that I'm not smarter than a million git developers.  Let's not
  # be too clever here.  It turns out that ordinary rebase already does a good
  # job of handilng the scenario where a parent has been rebased.
  local CHILD="$1"
  local PARENT="$2"
  local MB=""

  # check if child branch has an outstanding PR:
  local -a OPEN_PRS
  mapfile -t OPEN_PRS < <( _list_open_pr_numbers )
  if (( "${#OPEN_PRS[@]}" )); then
    _warn "Open PR exists for branch ${CHILD}: ${OPEN_PRS[*]}"
    _info "If a reviewer is already looking at your PR, rebasing this branch" \
          "will break the reviewer's ability to see what has changed when" \
          "you commit new changes.  Are you sure you want to do this?"
    if ! _confirm_default_no ; then
      _warn "Skipped update of branch ${CHILD}."
      return 0
    fi
  fi

  _set_main
  if [[ "${PARENT}" == "${MAIN}" ]]; then
    # ensure main gets updated from remote upstream main.
    _update_main
  fi

  # update BRANCH_TO_WORKTREE before rebasing, as this information
  # becomes unavailable when in detached head mode:
  _update_branch_to_worktree

  # TODO(jonathan): check if origin is ahead of local, and if so, do a git pull --rebase
  # operation.  This will allow multi-homed gee to work better.

  MB=$("${GIT}" merge-base "${PARENT}" "${CHILD}")  
  local -a COMMITS
  mapfile -t COMMITS < <(
    "${GIT}" log --oneline "${MB}..${CHILD}" )
  _info "" "Rebasing ${CHILD} onto ${PARENT} (${#COMMITS[@]} commits since ${MB}))."
  _debug "Will apply these commits:" \
        "${COMMITS[@]}"

  _checkout_or_die "${CHILD}"
  _silent_cmd "${GIT}" tag -f "${CHILD}.REBASE_BACKUP"
  local CHILD_DIR
  CHILD_DIR="$(_get_branch_rootdir "${CHILD}")"
  cd "${CHILD_DIR}"
  local PARENT_HEAD
  PARENT_HEAD="$(git show-ref "refs/heads/${PARENT}" | awk '{print $1}')"
  if ! _git rebase --autostash "${PARENT}" "${CHILD}"; then
    _warn "Rebase operation had conflicts."
    _interactive_conflict_resolution "${PARENT}" "${CHILD}"

    if _is_rebase_in_progress; then
      local STATUS
      mapfile -t STATUS < <( "${GIT}" status );
      _warn "${STATUS[@]}"
      _warn "Merge conflict in branch ${CHILD}, must be manually resolved."
      _fatal "Exited without resolving rebase conflict."
    fi

    if "${GIT}" merge-base --is-ancestor "${PARENT_HEAD}" HEAD; then
      _info "Rebase merge confirmed."
    else
      _warn "Rebase did not succeed, aborting."
      return 1
    fi
  fi

  _info "To undo: git checkout ${CHILD}; git reset --hard ${CHILD}.REBASE_BACKUP"
  _git push --quiet -u origin "+${CHILD}"
}

function _is_rebase_in_progress() {
  # Is this branch currently in the middle of a rebase operation?
  local G
  G="$(git rev-parse --git-dir)"
  if compgen -G "${G}/rebase*" > /dev/null; then
    return 0  # 0=true
  else
    return 1  # 1=false
  fi
}

function _checkout_or_die() {
  # we want to check out a branch.  Maybe there is already a
  # worktree.  Maybe we need to create a worktree.  Let's do
  # whatever is necessary.
  local BRANCH BRDIR
  BRANCH="$1"; shift
  # Do we already have a worktree?
  BRDIR="${REPO_DIR}/${BRANCH}"
  if ! [[ -d "${BRDIR}" ]]; then
    _git worktree add "${REPO_DIR}/${BRANCH}"
    BRDIR="$(_get_branch_rootdir "${BRANCH}")"
    _info "Created ${BRDIR}"
  fi
  cd "${BRDIR}"
  local CUR_BRANCH
  CUR_BRANCH="$(_get_current_branch)"
  if [[ "${CUR_BRANCH}" != "${BRANCH}" ]]; then
    _warn "${BRDIR} pointed to branch ${CUR_BRANCH} instead of ${BRANCH}."
    _git checkout "${BRANCH}"
    _info "... Fixed."
  fi
}

function _in_gee_repo() {
  # Return "main" if we are outside of a gee repo:
  if [[ "${PWD}" =~ ^"${HOME}"/gee/[a-zA-Z0-9_-]+ ]]; then
    return "${TRUE}"
  else
    return "${FALSE}"
  fi
}

function _in_gee_branch() {
  # Return "main" if we are outside of a gee repo:
  if [[ "${PWD}" =~ ^"${HOME}"/gee/[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+ ]]; then
    return "${TRUE}"
  else
    return "${FALSE}"
  fi
}

function _get_current_branch() {
  # Outside of a gee repo, current branch is always "main":
  _set_main
  if ! _in_gee_repo; then
    echo "${MAIN}"
    return
  fi
  # Inside of a gee repo, use git rev-parse:
  local CB
  CB="$("${GIT}" rev-parse --abbrev-ref HEAD)"
  if [[ -z "${CB}" ]]; then
    _die "Could not get current branch in directory $("${PWD}")"
  fi
  echo "${CB}"
}

function _update_main() {
  # Merge from upstream/main into main:
  _set_main
  _checkout_or_die "${MAIN}"
  # check for local changes
  local -a CHANGES
  read -r -a CHANGES < \
    <( "${GIT}" diff --name-only ) \
    || /bin/true
  if [[ "${#CHANGES[@]}" != 0 ]]; then
    _warn "${MAIN} branch contains uncommitted changes."
  fi
  _git fetch upstream
  local -a COUNTS
  read -r -a COUNTS < \
    <( "${GIT}" rev-list --left-right --count "upstream/${MAIN}...${MAIN}" ) \
    || /bin/true
  if (( COUNTS[1] > 0 )); then
    _warn "Branch ${MAIN} contains ${COUNTS[1]} commits of local changes."
    _info "gee expects ${MAIN} to track upstream/${MAIN} with no local changes."
    if _confirm_default_no "Do you want to revert these local changes?"; then
      _git reset --hard "upstream/${MAIN}"
    fi
  fi
  _git pull --rebase upstream "${MAIN}"
  read -r -a COUNTS < \
    <( "${GIT}" rev-list --left-right --count "upstream/${MAIN}...${MAIN}" ) \
    || /bin/true
  if (( COUNTS[0] != 0 )); then
    _fatal "pull failed: upstream/${MAIN} is ${COUNTS[1]} commits ahead of ${MAIN}"
  fi
  _git push --quiet -u origin "+${MAIN}"
}

# The parents file keeps track of two things:
#   - parent: the branch that spawned the current branch
#   - mb: the commit id of the mergebase with the parent branch
#
# mb is updated every time a branch is rebased, and is used to keep track of
# the last mergebase of a child branch, even if the parent branch gets rebased.
# This allows us to defer rebase operations of children, even after parents get
# rebased.
#
# TODO(jonathan): is there a better way to track this information?
# TODO(jonathan): maybe we don't need to track MB after all?

# Lazy-load parents metadata:
function _read_parents_file() {
  # Update the global PARENTS associative array from a file.
  if (( PARENTS_FILE_IS_LOADED )); then
    return
  fi
  local PATH="${REPO_DIR}/.gee/parents"
  local KEY VALUE
  if [[ ! -d "${REPO_DIR}/.gee" ]]; then
    /usr/bin/mkdir "${REPO_DIR}/.gee"
  fi
  if [[ ! -f "${PATH}" ]]; then
    /usr/bin/touch "${PATH}"
  fi
  local BRANCH PARENT MB 
  while read -r BRANCH PARENT MB; do
    PARENTS["${BRANCH}"]="${PARENT}"
    MERGEBASES["${BRANCH}"]="${MERGEBASE}"
  done < "${PATH}"
  PARENTS_FILE_IS_LOADED=1
}

function _write_parents_file() {
  # Write back the global PARENTS associative array to a file.
  if ! (( PARENTS_FILE_IS_LOADED )); then
    return
  fi
  if [[ "${#PARENTS[@]}" -eq 0 ]]; then
    _warn "Almost wrote empty parents file!"
    return
  fi
  local PATH="${REPO_DIR}/.gee/parents"
  if [[ ! -d "${REPO_DIR}/.gee" ]]; then
    /usr/bin/mkdir "${REPO_DIR}/.gee"
  fi
  local KEY VALUE MB
  for KEY in "${!PARENTS[@]}"; do
    VALUE="${PARENTS["$KEY"]}"
    MB="${MERGEBASES["$KEY"]}"
    printf "%q %q %q\n" "${KEY}" "${VALUE}" "${MB}"
  done > "${PATH}"
}

ABNORMAL=1
function _cleanup() {
  # Ensure we always save the PARENTS file, even if we die:
  _write_parents_file
  # Warn the user if we terminated abnormally (for example, if set -e fired).
  if (( ABNORMAL == 1 )); then
    _warn "Abnormal termination."
  fi
}
trap _cleanup EXIT

function _join() {
  # Usage:  _join <delimiter> <elements...>
  # Example: _join "," "${ARRAY[@]}"
  local DELIM="$1"; shift
  local TEXT="$1"; shift
  TEXT+="$(printf "${DELIM}%s" "$@")"
  echo "${TEXT}"
}

function _get_pull_requests() {
  # Prints list of PRs associated with this branch.
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  # "gh pr view" arguments are similar to "gh pr create" but not identical.
  local FROM_BRANCH="${GHUSER}:${CURRENT_BRANCH}"
  if [[ "${UPSTREAM}" == "${GHUSER}" ]]; then
    # gh-cli treats this as a special case for some reason.
    FROM_BRANCH="${CURRENT_BRANCH}"
  fi
  "${GH}" pr view \
    --repo="${UPSTREAM}/${REPO}" "${FROM_BRANCH}" \
    --json "state,number,title" \
    --jq '[.state, .number, .title] | join(" ")' \
    || /bin/true
}

function _list_open_pr_numbers() {
  _get_pull_requests | grep ^OPEN | awk '{print $2}'
}

function _list_merged_pr_numbers() {
  _get_pull_requests | grep ^MERGED | awk '{print $2}'
}

function _gh_pr_view() {
  # Normalize the interface to calling "gh pr view"
  local CURRENT_BRANCH;
  CURRENT_BRANCH="$(_get_current_branch)"
  local FROM_BRANCH="${GHUSER}:${CURRENT_BRANCH}"
  if [[ "${UPSTREAM}" == "${GHUSER}" ]]; then
    # gh-cli treats this as a special case for some reason.
    FROM_BRANCH="${CURRENT_BRANCH}"
  fi
  _gh pr view --repo "${UPSTREAM}/${REPO}" "${FROM_BRANCH}"
}

##########################################################################
# init command
##########################################################################

_register_help "init" "initialize a new git workspace" <<'EOT'
Usage: gee init [<repo>]

Arguments:

   repo: Specifies which enfabrica repository to check out.
         If repo is not specified, `internal` is used by default.

`gee init` creates a new gee-controlled workspace in the user's home directory.
The directory `~/gee/<repo>/main` will be created and populated, and all
other branches will be checked out into `~/gee/<repo>/<branch>`.
EOT

function gee__init() {
  local R
  R="${1:-"${REPO}"}"
  REPO="${R}"
  REPO_DIR="${GEE_DIR}/${REPO}/"
  if (( "${TESTMODE}" )); then
    REPO_DIR="${HOME}/testgee/${REPO}/"
  fi

  # ensure all tools are installed.
  _install_tools

  if ! _check_ssh; then
    _warn "Cannot connect to github over ssh."
    _confirm_or_exit "Would you like to set up ssh access now? (y/N)  "
    _ssh_enroll
  fi

  gee__hello

  # _set_main won't work without a cloned repo, so assume MAIN for now
  # and fix the branch name later.
  MAIN=main
  _gh config set git_protocol ssh
  _check_gh_auth

  _info "Initializing ${REPO_DIR} for ${REPO}/${MAIN}"

  if [[ -d "${REPO_DIR}/${MAIN}" ]]; then
    _fatal \
      "Initialized workspace already exists in ${REPO_DIR}"
  fi
  _cmd mkdir -p "${REPO_DIR}/.gee"
  local URL UPSTREAM_URL
  URL="${GIT_AT_GITHUB}:${GHUSER}/${REPO}.git"
  UPSTREAM_URL="${GIT_AT_GITHUB}:${UPSTREAM}/${REPO}.git"

  # Make fork if needed
  if ! "${GH}" repo list | grep "^${GHUSER}/${REPO}" > /dev/null; then
    _gh repo fork --clone=false "${UPSTREAM}/${REPO}"
  fi
  _git clone --depth "${CLONE_DEPTH}" "${URL}" "${REPO_DIR}/${MAIN}"
  cd "${REPO_DIR}/${MAIN}"
  _git remote add upstream "${UPSTREAM_URL}"
  _git fetch upstream
  _git remote -v
 
  # Fix the name of the main branch to match the actual branch name: 
  local OLD_MAIN="${MAIN}"
  unset MAIN
  _set_main_by_asking_github
  cd "${REPO_DIR}"
  mv "${OLD_MAIN}" "${MAIN}"
  cd "${MAIN}"

  _info "Created ${REPO_DIR}/${MAIN}"
}

##########################################################################
# make_branch command
##########################################################################

_register_help "make_branch" \
  "Create a new child branch based on the current branch." \
  "mkbr" \
  <<'EOT'
Usage: gee make_branch <branch-name> [<commit-ish>]
Aliases: mkbr

Create a new branch based on the current branch.  The new branch will be located in the
directory:
  ~/gee/<repo>/<branch-name>

If <commit-ish> is provided, sets the HEAD of the newly created branch to that
revision.
EOT

function gee__mkbr() { gee__make_branch "$@"; }
function gee__make_branch() {
  local BRNAME SHA CURRENT_BRANCH
  # TODO(jonathan): Let the user name the branch to branch from.
  BRNAME="$1"; shift
  SHA="$1"

  _set_main
  CURRENT_BRANCH="$(_get_current_branch)"
  if [[ -z "${CURRENT_BRANCH}" ]]; then
    CURRENT_BRANCH="${MAIN}"
  fi
  _checkout_or_die "${CURRENT_BRANCH}"

  local -a ARGS=( worktree add "${REPO_DIR}/${BRNAME}" )
  if [[ -n "${SHA}" ]]; then
    ARGS+=( "${SHA}" )
  fi
  _git "${ARGS[@]}"
  _info "Created ${REPO_DIR}/${BRNAME}"

  _read_parents_file
  PARENTS["${BRNAME}"]="${CURRENT_BRANCH}"
  _write_parents_file

  # If the user has created a branch whose name matches an
  # existing branch in their existing repo, pull those changes
  # into this branch.
  if _remote_branch_exists origin "${BRNAME}"; then
    _checkout_or_die "${BRNAME}"
    _git pull --rebase origin "${BRNAME}"
    _info "Pulled in changes from origin/${BRNAME}"
  fi
}

##########################################################################
# log command
##########################################################################

_register_help "log" \
  "Log of commits since parent branch." <<'EOT'
Usage: gee log
EOT

function gee__log() {
  _check_cwd
  local -a ARGS=( "$@" )
  local -a RANGE=()
  _egrep_array RANGE '^\w*\.\.\.\w*$' "$@"
  if (( ${#RANGE[@]} == 0 )); then
    local PARENT_BRANCH CURRENT_BRANCH
    _read_parents_file
    PARENT_BRANCH="$(_get_parent_branch)"
    CURRENT_BRANCH="$(_get_current_branch)"
    ARGS+=("${PARENT_BRANCH}...${CURRENT_BRANCH}")
  fi
  local -a PRETTYLOG=(
      log
      --color
      --graph 
      "--pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'"
      --abbrev-commit
  )
  _set_alias_if_missing logp "${PRETTYLOG[*]}"
  _git logp "${ARGS[@]}"
}

##########################################################################
# diff command
##########################################################################

_register_help "diff" \
  "Differences in this branch." <<'EOT'
Usage: gee diff [<files...>]

Shows changes since this branch diverged from it's parent branch.

If <files...> are omited, defaults to all files.
EOT

function gee__diff() {
  _check_cwd
  local PARENT_BRANCH CURRENT_BRANCH MERGE_BASE
  _read_parents_file
  PARENT_BRANCH="$(_get_parent_branch)"
  CURRENT_BRANCH="$(_get_current_branch)"
  MERGE_BASE="$("${GIT}" merge-base "${PARENT_BRANCH}" "${CURRENT_BRANCH}")"
  if (( "$#" )); then
    _git_can_fail diff "${PARENT_BRANCH}...${CURRENT_BRANCH}" -- "$@"
  else
    _git_can_fail diff "${PARENT_BRANCH}...${CURRENT_BRANCH}"
  fi
}

##########################################################################
# pack command
##########################################################################

_register_help "pack" \
  "Exports all unsubmitted changes in this branch as a pack file." <<'EOT'
Usage: gee pack [-c] [-o <file.pack>]

Creates a pack file containing all unsubmitted changes in this branch.

Flags:
  -o  Specifies a file to write to, instead of stdout.

EOT

function gee__pack() {
  _check_cwd
  _set_main
  declare -A FLAGS=()
  _parse_options "o:" "$@"
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  local STATUS
  STATUS="$("${GIT}" status --porcelain)"
  if [[ -n "${STATUS}" ]]; then
    _warn "You have uncommitted work in this branch that won't be packed."
    _confirm_or_exit "Do you want to proceed anyway? (y/N)  "
  fi
  local HEAD_COMMIT
  HEAD_COMMIT="$("${GIT}" rev-parse HEAD)"
  local -a OPTS=( --inter-hunk-context=3 )
  local OUTPUT
  OUTPUT="${FLAGS[o]}"
  if [[ -n "${OUTPUT}" ]]; then
    _info "Writing to ${OUTPUT}"
    exec >"${OUTPUT}"
  else
    _info "Writing to stdout"
  fi
  (
    echo "PACKFILE v1.0"
    echo "User: $(whoami)"
    echo "Date: $(date)"
    echo "Branch: ${CURRENT_BRANCH}"
    echo "Head: ${HEAD_COMMIT}"
    echo ""
    echo "git diff "${OPTS[@]}" ${MAIN}...${CURRENT_BRANCH}"
    echo "### start of patch"
    "${GIT}" diff "${MAIN}...${CURRENT_BRANCH}"
    echo "### end of patch"
  ) </dev/null
}

##########################################################################
# unpack command
##########################################################################

_register_help "unpack" \
  "Patch the local branch from a pack file." <<'EOT'
Usage: gee unpack <file.pack>

"unpack" attempts to patch the current branch from a pack file.
EOT

function gee__unpack() {
  _check_cwd
  _set_main
  local PACKFILE
  PACKFILE="$1"
  if [[ -z "${PACKFILE}" ]]; then
    _fatal "unpack: you must specify a pack file to read."
  fi
  if ! [[ -f "${PACKFILE}" ]]; then
    _fatal "unpack: Could not find \"${PACKFILE}\""
  fi
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  local STATUS
  STATUS="$("${GIT}" status --porcelain)"
  if [[ -n "${STATUS}" ]]; then
    _warn "You have uncommitted work in this branch that could be disrupted."
    _confirm_or_exit "Do you want to proceed anyway? (y/N)  "
  fi
  cd "$(_get_branch_rootdir "${CURRENT_BRANCH}")"
  local -a HEADER=()
  local LINE
  while IFS= read -r LINE; do
    if [[ -z "${LINE}" ]]; then
      break
    fi
    HEADER+=( "${LINE}" )
  done <"${PACKFILE}"
  _info "Applying ${PACKFILE}:" "${HEADER[@]}" ""
  patch -p1 <"${PACKFILE}"
}


## DEPRECATED: we always squash when submitting a PR, this command adds a lot
## of complexity but very little value.
## TODO(jonathan): delete this after we are sure we don't need it.
## ##########################################################################
## # squash command
## ##########################################################################
## 
## _register_help "squash" "Squash all commits in this branch." <<'EOT'
## Usage: gee squash
## 
## Squash all commits in this branch to a single commit.
## EOT
## 
## function gee__squash() {
##   _check_cwd
##   # Note: there is no longer any need to squash before sending out for review,
##   # as we always merge with "gh pr merge --squash".
##   # TODO(jonathan): Deprecate this?
##   local PARENT_BRANCH CURRENT_BRANCH MERGE_BASE TMPFILE NUM_COMMITS
##   _read_parents_file
##   PARENT_BRANCH="$(_get_parent_branch)"
##   CURRENT_BRANCH="$(_get_current_branch)"
##   MERGE_BASE="$("${GIT}" merge-base "${PARENT_BRANCH}" "${CURRENT_BRANCH}")"
##   NUM_COMMITS="$("${GIT}" log --oneline "${PARENT_BRANCH}..${CURRENT_BRANCH}" | /usr/bin/wc -l)"
##   _info "Current branch: ${CURRENT_BRANCH}"
##   _info "Parent branch: ${PARENT_BRANCH}"
##   _info "Merge base: ${MERGE_BASE}"
##   _info "Number of commits outstanding: ${NUM_COMMITS}"
##   if [[ "${NUM_COMMITS}" -lt 2 ]]; then
##     _fatal "${NUM_COMMITS} commits outstanding.  Nothing to squash."
##   fi
##   TMPFILE="$(mktemp)"
##   (
##     echo "# Comment lines will be removed."
##     echo "# One line summary:"
##     echo "[REPLACE THIS LINE]"
##     echo ""
##     echo "# Details:"
##     echo ""
##     echo "Files:"
##     "${GIT}" diff --name-only "${MERGE_BASE}" | sed 's/^/    /'
##     echo ""
##     echo "# Previous commit messages:"
##     echo "#"
##     "${GIT}" log --format=medium "${PARENT_BRANCH}..${CURRENT_BRANCH}" | \
##       sed 's/^/# /'
##     echo ""
##   ) >"${TMPFILE}"
##   "${EDITOR:-vim}" "${TMPFILE}"
##   sed -i "/^#/d" "${TMPFILE}"
##   perl -p -i -e 's/(^\s*\n){2,}/\n/gmso' "${TMPFILE}"
##   if grep -q "^\[REPLACE" "${TMPFILE}"; then
##     echo "You must replace the summary line."
##     echo "Commit message saved here: ${TMPFILE}"
##     _fatal Aborted.
##   fi
##   head -n 1 "${TMPFILE}"
##   _confirm_or_exit \
##     "Are you sure you want to squash ${NUM_COMMITS} commits? (y/N)  "
## 
##   _git reset --soft "${MERGE_BASE}"
##   _git add --all
##   _git commit -a -F "${TMPFILE}"
##   rm "${TMPFILE}"
##   _git push -u origin "+${CURRENT_BRANCH}"  # update remote branch too
##   _git log --oneline "${PARENT_BRANCH}..${CURRENT_BRANCH}"
## }

##########################################################################
# update command
##########################################################################

_register_help "update" \
  "integrate changes from parent into this branch." \
  "up" \
  <<'EOT'
Usage: gee update

"gee update" attempts to rebase this branch atop its parent branch.

If a merge conflict occurs, "gee" drops the user into a sub-shell where the
user can either resolve the conflicts and continue, or abort the entire
operation.
EOT

function gee__up() { gee__update "$@"; }
function gee__update() {
  _check_cwd
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  if [[ -z "${CURRENT_BRANCH}" ]]; then
    _die "Not in a git branch directory."
  fi

  # Check for upstream changes in "origin" first:
  if _remote_branch_exists origin "${CURRENT_BRANCH}"; then
    _git fetch
    local -a COUNTS
    read -r -a COUNTS < <("${GIT}" rev-list --left-right --count "${CURRENT_BRANCH}...origin/${CURRENT_BRANCH}")
    if [[ "${COUNTS[1]}" -gt 0 ]]; then
      _warn "Remote branch origin/${CURRENT_BRANCH} is ${COUNTS[1]} commit(s) ahead of ${CURRENT_BRANCH}."
      _info "This could be caused by commiting changes to this branch from a different machine, " \
            "or possibly you rebased your branch without pushing the updated branch to origin."
      if _confirm_default_yes "Do you want to integrate changes from origin/${CURRENT_BRANCH}? (Y/n)  "; then
        _info "Pulling in changes from origin/${CURRENT_BRANCH}"
        HEAD="$("${GIT}" rev-parse HEAD)"
        _info "Old head commit before rebase: ${HEAD}"
        _git rebase --autostash "origin/${CURRENT_BRANCH}"
      fi
    fi
  fi

  _read_parents_file

  local PREVIOUS_B
  PREVIOUS_B="$(_get_parent_branch "${CURRENT_BRANCH}")"

  _set_main
  if [[ "${PREVIOUS_B}" == "${MAIN}" ]]; then
    # only update main branch if we're merging from it.
    _update_main
  fi

  _checkout_or_die "${CURRENT_BRANCH}"
  # Rebase from PREVIOUS_B onto B
  _rebase_child_onto_parent "${CURRENT_BRANCH}" "${PREVIOUS_B}"
  _info Done.
}

##########################################################################
# rupdate command
##########################################################################

_register_help "rupdate" \
  "Recursively integrate changes from parents into this branch." \
  "rup" <<'EOT'
Usage: gee rupdate

"gee rupdate" recursively rebases each branch onto it's parent.

If a merge conflict occurs, "gee" drops the user into a sub-shell where the
user can either resolve the conflicts and continue, or abort the entire
operation.  Note that the merge conflict can be in a parent of the current
branch.
EOT

function gee__rup() { gee__rupdate "$@"; }
function gee__rupdate() {
  _check_cwd
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  if [[ -z "${CURRENT_BRANCH}" ]]; then
    _die "Not in a git branch directory."
  fi


  _read_parents_file

  # Build a chain of branches to update.
  _set_main
  local -a CHAIN=()
  local B
  B="${CURRENT_BRANCH}"
  while [[ "${B}" != "${MAIN}" ]]; do
    CHAIN=( "${B}" "${CHAIN[@]}" )
    B="$(_get_parent_branch "${B}")"
    if (( "${#CHAIN[@]}" > 50 )); then
      _info "CHAIN: ${CHAIN[*]}"
      _die "Branch chain is longer than 50, that can't be right."
    fi
  done

  local PREVIOUS_B
  PREVIOUS_B="${MAIN}"
  for B in "${CHAIN[@]}"; do
    _banner "Updating branch \"${B}\""
    _checkout_or_die "${B}"

    # Check if we're rebasing onto a branch with uncommitted changes:
    if [[ "${B}" != "${CURRENT_BRANCH}" ]]; then
      local -a UNCOMMITTED
      mapfile -t UNCOMMITTED < <( "${GIT}" status --short -uall )
      if (( "${#UNCOMMITTED[@]}" )); then
        _warn "Branch ${B} contains ${#UNCOMMITTED[@]} uncommitted changes:" \
          "${UNCOMMITTED[@]}" \
          "Child branches won't get uncommitted changes."
      fi
      # rebase always uses --autostash, so we'll proceed.
    fi

    # Rebase from PREVIOUS_B onto B
    _rebase_child_onto_parent "${B}" "${PREVIOUS_B}"
    PREVIOUS_B="${B}"
  done
  _info Done.
}

##########################################################################
# update_all command
##########################################################################

_register_help "update_all" \
  "Update all branches."  \
  "up_all" <<'EOT'
Usage: gee update_all

"gee update_all" updates all local branches (in the correct order),
by rebasing child branches onto parent branches.

If a merge conflict occurs, "gee" drops the user into a sub-shell where the
user can either resolve the conflicts and continue, or abort the entire
operation.  Note that the merge conflict can be in a parent of the current
branch.
EOT

function _order_branches() {
  local B="$1"
  if _contains_element "${B}" "${CHAIN[@]}"; then return; fi
  if [[ "${B}" == "${MAIN}" ]]; then return; fi
  _order_branches "$(_get_parent_branch "${B}")"
  if (( "${#CHAIN[@]}" > 500 )); then
    _info "CHAIN: ${CHAIN[*]}"
    _die "_order_branches recursed too deeply."
  fi
  CHAIN+=( "${B}" )
}

function gee__up_all() { gee__update_all "$@"; }
function gee__update_all() {
  local -a CONFLICTS=()
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  if [[ -z "${CURRENT_BRANCH}" ]]; then
    _set_main
    CURRENT_BRANCH="${MAIN}"
    _checkout_or_die "${CURRENT_BRANCH}"
  fi

  # Merge from upstream/main into main:
  _update_main

  _read_parents_file

  # Build an ordered list of branches to update
  local -a ALL_BRANCHES=()
  mapfile -t ALL_BRANCHES < <( "${GIT}" branch --format="%(refname:short)" )
  local -a CHAIN=()
  local B
  for B in "${ALL_BRANCHES[@]}"; do
    _order_branches "${B}"
  done
  _info "Updating ${CHAIN[*]}"

  local PARENT
  for B in "${CHAIN[@]}"; do
    _banner "Updating branch \"${B}\""
    _checkout_or_die "${B}"

    # Check if we're rebasing onto a branch with uncommitted changes:
    if [[ "${B}" != "${CURRENT_BRANCH}" ]]; then
      local -a UNCOMMITTED
      mapfile -t UNCOMMITTED < <( "${GIT}" status --short -uall )
      if (( "${#UNCOMMITTED[@]}" )); then
        _warn "Branch ${B} contains ${#UNCOMMITTED[@]} uncommitted changes:" \
          "${UNCOMMITTED[@]}" \
          "Child branches won't get uncommitted changes."
      fi
      # rebase always uses --autostash, so we'll proceed.
    fi

    # Rebase from PREVIOUS_B onto B
    PARENT="$(_get_parent_branch "${B}")"
    if ! _rebase_child_onto_parent "${B}" "${PARENT}"; then
      CONFLICTS+=( "${B}" )
    fi
  done
  if (( "${#CONFLICTS[@]}" )); then
    _fatal "The following branches had merge conflicts:" "${CONFLICTS[@]}"
  fi
  _info Done.
}

##########################################################################
# whatsout command
##########################################################################

_register_help "whatsout" \
  "List locally changed files in this branch." <<'EOT'
Usage: gee whatsout

Reports which files differ from main.
EOT

function gee__whatsout() {
  _check_cwd
  local BRANCH MERGEBASE
  BRANCH="$(_get_current_branch)"
  _set_main
  MERGEBASE="$(git merge-base "origin/${MAIN}" "${BRANCH}")"
  _git diff --name-only "${MERGEBASE}" 
}

##########################################################################
# lsbranches command
##########################################################################
# TODO(jonathan): maybe display a tree?
# TODO(jonathan): maybe display this suggestion from Jacob Adelmann:
# branchp = !git for-each-ref \
#   --sort=committerdate refs/heads/ \
#   --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'

_register_help "lsbranches" \
  "List information about each branch." \
  "lsb" "lsbr" <<'EOT'
Usage: gee lsbranches

List information about all branches.

NOTE: the output of this command is likely to change in the near future.
EOT

function gee__lsb() { gee__lsbranches "$@"; }
function gee__lsbr() { gee__lsbranches "$@"; }
function gee__lsbranches() {
  _set_main
  if ! _in_gee_repo; then
    cd "${REPO_DIR}"
  fi
  if ! _in_gee_branch; then
    cd "${REPO_DIR}/${MAIN}"
  fi

  local -a branches;
  mapfile -t branches < <( "${GIT}" branch --format "%(refname:short)")
  local br
  _set_main
  _git fetch
  for br in "${branches[@]}"; do
    if [[ "${br}" != "${MAIN}" ]]; then
      _branch_ahead_behind "${br}"
    fi
  done
}

##########################################################################
# cleanup command
##########################################################################
_register_help "cleanup" \
  "Automatically remove branches without local changes." <<'EOT'
Usage: gee cleanup

Automatically removes branches without local changes.
EOT

function gee__cleanup() {
  _set_main
  _read_parents_file

  if ! _in_gee_repo; then
    cd "${REPO_DIR}"
  fi
  if ! _in_gee_branch; then
    cd "${REPO_DIR}/${MAIN}"
  fi

  local -a branches;
  mapfile -t branches < <( "${GIT}" branch --format "%(refname:short)")

  local -a empty=()
  local br
  for br in "${branches[@]}"; do
    if [[ "${br}" != "${MAIN}" ]]; then
      local parent
      parent="$(_get_parent_branch "${br}")"
      local -a  counts=()
      read -r -a counts < <("${GIT}" rev-list --left-right --count "${parent}...${br}")
      _checkout_or_die "${br}"
      if [[ -z "$("${GIT}" status --porcelain)" ]]; then
        if (( counts[1] == 0 )); then
          empty+=( "${br}" )
        fi
      fi
    fi
  done

  _info "The following branches have no local changes:"
  _info "  ${empty[*]}"
  _checkout_or_die "${MAIN}"
  for br in "${empty[@]}"; do
    if _confirm_default_no "Do you want to remove the \"${br}\" branch? (y/N)  "; then
      gee__rmbr "${br}"
    fi
  done
}

##########################################################################
# get_parent command
##########################################################################

_register_help "get_parent" \
  "Which branch is this branch branched from?" <<'EOT'
Usage: gee get_parent
EOT

function gee__get_parent() {
  _check_cwd
  local BRANCH
  BRANCH="${1:-$(_get_current_branch)}"
  _read_parents_file
  PARENT="$(_get_parent_branch "${BRANCH}")"
  echo "${PARENT} is the parent branch of ${BRANCH}"
}

##########################################################################
# set_parent command
##########################################################################

_register_help "set_parent" \
  "Set another branch as parent of this branch." <<'EOT'
Usage: gee set_parent <parent-branch>

Gee keeps track of which branch each branch is branched from.  You can
change the parent of the current branch with this command, but be sure
to do a "gee update" operation afterwards.
EOT

function gee__set_parent() {
  _check_cwd
  local BRANCH PARENT 
  BRANCH="$(_get_current_branch)"
  PARENT="$1"
  if [[ -z "${PARENT}" ]]; then
    _fatal "Must specify a parent branch."
  fi
  _read_parents_file
  PARENTS["${BRANCH}"]="$1"
  _write_parents_file
  echo "${PARENT} is the parent branch of ${BRANCH}"
}

##########################################################################
# commit command
##########################################################################

_register_help "commit" \
  "Commit all changes in this branch" \
  "push" "c" <<'EOT'
Usage: gee commit [<git commit options>]

Commits all outstanding changes (to the local branch, not the upstream branch),
and uploads that commit to the user's private github repo.  "commit" can be
used to checkpoint and back up work in progress.

Example:

    gee commit -m "Added \"gee commit\" command."
EOT

function gee__push() { gee__commit "$@"; }
function gee__c() { gee__commit "$@"; }
function gee__commit() {
  _check_cwd
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  _set_main
  if [[ "${CURRENT_BRANCH}" == "${MAIN}" ]]; then
    _info "gee's workflow doesn't allow changes to the ${MAIN} branch."
    _info "You should move your changes to another branch.  For example:"
    _info "  git add -a; git stash; gee mkbr new1; gcd new1; git stash apply"
    _fatal "Commit to ${MAIN} branch denied."
  fi
  BRANCH_DIR="$(_get_branch_rootdir "${CURRENT_BRANCH}")"
  _debug "${BRANCH_DIR}" "${HOME}"
  if [[ "${BRANCH_DIR}" != "${HOME}" ]]; then
    _git add --all
  else
    echo "Skipped \"git add --all\" because branch is home dir."
  fi
  if _git_can_fail commit "$@"; then
    if _remote_branch_exists origin "${CURRENT_BRANCH}"; then
      _git fetch
      local -a COUNTS
      read -r -a COUNTS < <("${GIT}" rev-list --left-right --count "${CURRENT_BRANCH}...origin/${CURRENT_BRANCH}")
      if [[ "${COUNTS[1]}" -gt 0 ]]; then
        _warn "Remote branch origin/${CURRENT_BRANCH} is ${COUNTS[1]} commit(s) ahead of ${CURRENT_BRANCH}."
        _warn "You must integrate upstream changes before pushing."
        if _confirm_default_yes "Do you want to pull upstream changes now? (Y/n)  "; then
          _git rebase --autostash "origin/${CURRENT_BRANCH}"
        else
          _warn "Skipping backup of branch to origin/${CURRENT_BRANCH}"
          return 0
        fi
      fi
    fi
    # We always push upstream so that users have a backup in case they lose their
    # laptop:
    _git push -u origin "${CURRENT_BRANCH}"
  fi
}

##########################################################################
# pr_checkout command
##########################################################################
_register_help "pr_checkout" \
  "Create a client containing someone's pull request." <<'EOT'
Usage: gee pr_checkout <PR>

Creates a new branch containing the specified pull request.
Lists PRs that you created, and that are assigned to you.
EOT
function gee__pr_checkout() {
  _check_gh_auth
  _set_main
  _checkout_or_die "${MAIN}"
  local PRNUM="$1"; shift
  local BRANCH="pullreq_${PRNUM}"
  if _local_branch_exists "${BRANCH}"; then
    _confirm_or_exit "Branch ${BRANCH} exists: okay to reset it?  "
  fi
  # TODO(jonathan): will this update an existing branch?
  _git fetch upstream "pull/${PRNUM}/head:${BRANCH}"
  if ! _local_branch_exists "${BRANCH}"; then
    gee__mkbr "${BRANCH}"
  fi
  _checkout_or_die "${BRANCH}"
  git push origin "${BRANCH}"
  _info "Pulled PR #${PRNUM} into branch \"${BRANCH}\""
} 

##########################################################################
# pr_list command
##########################################################################
_register_help "pr_list" \
  "List outstanding PRs" \
  "lspr" "list_pr" "prls" <<'EOT'
Usage: gee pr_list [<user>]

Lists information about PRs associated with the specified user (or yourself, if
no user is specified).

Example:

$ gee lspr jonathan-enf
PRs associated with this branch:
OPEN 1181 codegen tool

Open PRs authored by jonathan-enf:
#1205   REVIEW_REQUIRED Fix libsystemc build file error.
#1181   REVIEW_REQUIRED codegen tool
#1158   REVIEW_REQUIRED Added @gmp//:libgmpxx
#1148   REVIEW_REQUIRED Added gee to enkit.config.yaml.
#1136   REVIEW_REQUIRED Unified PtrQueue and Queue implementations.
#1130   REVIEW_REQUIRED Owners of /poc/{sim,models}
#1059   REVIEW_REQUIRED CSV file helper library

PRs pending their review:
#1200  taoliu0  2021-08-12T15:26:03Z  Added an example integrating SC

EOT
function gee__lspr() { gee__pr_list "$@"; }
function gee__list_pr() { gee__pr_list "$@"; }
function gee__prls() { gee__pr_list "$@"; }
function gee__pr_list() {
  _check_gh_auth
  local WHO WHO_3RD_PERSON USER YOUR
  WHO="@me"
  WHO_3RD_PERSON="you"
  USER="${GHUSER}"
  YOUR="your"
  if [[ -n "$1" ]]; then
    WHO="$1"
    WHO_3RD_PERSON="$1"
    USER="$1"
    YOUR="their"
  fi
  if _in_gee_branch; then
    _info "PRs associated with this branch:"
    _get_pull_requests
    echo ""
  fi

  _info "Open PRs authored by ${WHO_3RD_PERSON}:"
  ( printf "PR\tbranch\treview\ttitle\n" ; \
    printf "==\t======\t======\t=====\n" ; \
   "${GH}" --repo "${UPSTREAM}/${REPO}" pr list --author "${WHO}" --state open \
    --json number,reviewDecision,headRefName,title \
    --jq '.[] | "#\(.number)\t\(.headRefName)\t\(.reviewDecision)\t\(.title)"' \
    ) | column -t -s $'\t'
  echo ""

  _info "PRs pending ${YOUR} review:"
  # TODO(jonathan): ugh why doesn't this work?
  local -a JQSCRIPT=(
    '.[]'
    ' | select( .reviewDecision == "REVIEW_REQUIRED" )'
    ' | select( .reviewRequests[]? | contains({"login":"'"${USER}"'"}))'
    ' | "#\(.number)\t\(.author.login)\t\(.createdAt)\t\(.title)"'
  )
  ( printf "PR\tauthor\tcreated\ttitle\n" ; \
    printf "==\t======\t=======\t=====\n" ; \
   "${GH}" --repo "${UPSTREAM}/${REPO}" pr list \
    --json number,author,headRefName,createdAt,state,title,reviewDecision,reviewRequests \
    --jq "${JQSCRIPT[*]}" \
    ) | column -t -s $'\t'
}

##########################################################################
# edit_pr command
##########################################################################

_register_help "pr_edit" \
  "Edit an existing pull request." \
  "edpr" "pred" "edit_pr" <<'EOT'
Usage: gee edit_pr <args>

Edit an outstanding pull request.

All arguments are passed to "gh pr edit".
EOT

function gee__edpr() { gee__pr_edit "$@"; }
function gee__pred() { gee__pr_edit "$@"; }
function gee__edit_pr() { gee__pr_edit "$@"; }
function gee__pr_edit() { 
  _check_cwd
  _check_gh_auth
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  local FROM_BRANCH="${GHUSER}:${CURRENT_BRANCH}"
  if [[ "${UPSTREAM}" == "${GHUSER}" ]]; then
    # gh-cli treats this as a special case for some reason.
    FROM_BRANCH="${CURRENT_BRANCH}"
  fi

  if ! _gh_pr_view > /dev/null; then
    _fatal "No pull request exists for ${GHUSER}:${CURRENT_BRANCH}."
  fi

  # The same view options also work for pr edit:
  _gh pr edit --repo "${UPSTREAM}/${REPO}" "${FROM_BRANCH}" "$@"
}

##########################################################################
# pr_debug command
#
# gh api for querying pull requests is pretty wonky, this is a temporary
# command used to get some visibility into the API.
##########################################################################

function gee__pr_debug() {
  _check_cwd
  _check_gh_auth
  local -a PRS=()
  mapfile -t PRS < <( _list_open_pr_numbers )
  _info "Open pull requests: ${PRS[*]}"
  mapfile -t PRS < <( _list_merged_pr_numbers )
  _info "Merged pull requests: ${PRS[*]}"
}

##########################################################################
# view_pr command
##########################################################################

_register_help "pr_view" \
  "View an existing pull request." \
  "view_pr" <<'EOT'
Usage: gee pr_view

View an outstanding pull request.
EOT

function gee__view_pr() { gee__pr_view "$@"; }
function gee__pr_view() {
  _check_cwd
  _check_gh_auth
  if ! _gh_pr_view; then
    _fatal "No pull request exists for ${GHUSER}:${CURRENT_BRANCH}."
  fi
}

##########################################################################
# make_pr command
##########################################################################

_register_help "pr_make" \
  "Creates a pull request from this branch." \
  "mail" "send" "make_pr" "mkpr" "prmk" <<'EOT'
Usage: gee make_pr <gh-options>

Creates a new pull request from this branch.

Uses the same options as "gh pr create".
EOT

function gee__mail() { gee__pr_make "$@"; }
function gee__send() { gee__pr_make "$@"; }
function gee__mkpr() { gee__pr_make "$@"; }
function gee__prmk() { gee__pr_make "$@"; }
function gee__make_pr() { gee__pr_make "$@"; }
function gee__pr_create() { gee__pr_make "$@"; }
function gee__create_pr() { gee__pr_make "$@"; }
function gee__pr_make() {
  _check_cwd
  _check_gh_auth
  local DEST_BRANCH CURRENT_BRANCH MERGE_BASE NUM_COMMITS
  _git fetch upstream
  _read_parents_file
  _set_main
  DEST_BRANCH="upstream/${MAIN}"
  CURRENT_BRANCH="$(_get_current_branch)"
  MERGE_BASE="$("${GIT}" merge-base "${DEST_BRANCH}" "${CURRENT_BRANCH}")"
  _info "Current branch: ${CURRENT_BRANCH}"
  _info "Destination branch: ${DEST_BRANCH}"
  _info "Merge base: ${MERGE_BASE}"

  local -a OPEN_PRS
  mapfile -t OPEN_PRS < <( _list_open_pr_numbers )
  if (( "${#OPEN_PRS[@]}" )); then
    _info "Open PR exists: ${OPEN_PRS[*]}" \
          "Use \"gee commit\" to update existing PR."
    _fatal Aborted.
  fi

  local UNCOMMITTED
  UNCOMMITTED="$("${GIT}" status --short -uall | wc -l)"
  if [[ "${UNCOMMITTED}" -gt 0 ]]; then
    echo "Branch contains ${UNCOMMITTED} uncommitted changes:"
    _git status --short -uall
    echo "Run \"gee commit\" and try again."
    _fatal Aborted.
  fi

  NUM_COMMITS="$("${GIT}" log --oneline "${DEST_BRANCH}..${CURRENT_BRANCH}" | wc -l)"
  if [[ "${NUM_COMMITS}" -eq 0 ]]; then
    _debug "command: ${GIT} log --oneline ${DEST_BRANCH}..${CURRENT_BRANCH}"
    _fatal "No changes in this branch."
  fi

  local FROM_BRANCH="${GHUSER}:${CURRENT_BRANCH}"
  if [[ "${UPSTREAM}" == "${GHUSER}" ]]; then
    # gh-cli treats this as a special case for some reason.
    FROM_BRANCH="${CURRENT_BRANCH}"
  fi

  # Note: there is no longer any need to squash before sending out for review,
  # as we always merge with "gh pr merge --squash".

  # Note: we must label origin as the upstream branch for "gh pr create" to
  # automatically pick the branch to use for the PR request.
  _git push -u origin "${CURRENT_BRANCH}"
  # gh pr is arcane and confusing, but this works:
  #  -R specifies the repo that we are pushing changes into.
  #  -H specifies the branch that contains outstanding commits,
  #     formatted username:branchname.
  #  -B specifies the branch we want to merge to, defaults to ${UPSTREAM}:${MAIN}
  local -a PR_ARGS
  PR_ARGS+=( --repo "${UPSTREAM}/${REPO}" -H "${GHUSER}:${CURRENT_BRANCH}" )
  PR_ARGS+=( "$@" )
  _gh pr create "${PR_ARGS[@]}"
  # _gh pr checks  # not sure why this is problematic.
  _gh_pr_view
  local NUM_REVIEWERS
  NUM_REVIEWERS="$(gh pr view \
    --repo "${UPSTREAM}/${REPO}" "${GHUSER}:${CURRENT_BRANCH}" \
    --json reviewRequests --jq '.reviewRequests | length')"
  if (( NUM_REVIEWERS == 0 )); then
    _warn "Don't forget to add reviewers!"
  fi
}
  

##########################################################################
# submit_pr command
##########################################################################

_register_help "pr_submit" \
  "Merge the approved PR into the parent branch." \
  "merge" "submit_pr" <<'EOT'
Usage: gee submit_pr

Merges an approved pull request.
EOT
function gee__submit_pr() { gee__pr_submit "$@"; }
function gee__merge() { gee__pr_submit "$@"; }
function gee__pr_submit() {
  _check_cwd
  _check_gh_auth
  local CURRENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  if ! _remote_branch_exists origin "${CURRENT_BRANCH}"; then
    _die "Remote branch ${CURRENT_BRANCH} does not exist."
  fi
  local DIFFS
  DIFFS="$("${GIT}" diff --name-only \
    "origin/${CURRENT_BRANCH}..${CURRENT_BRANCH}" | wc -l)"
  if (( "${DIFFS}" != 0 )); then
    _fatal "Will not submit: current branch has uncommitted changes."
  fi

  # Get some information about this PR before we merge.
  _set_main
  local MERGEBASE
  MERGEBASE="$( "${GIT}" merge-base "upstream/${MAIN}" "origin/${CURRENT_BRANCH}" )"
  _info "Merge base: ${MERGEBASE}"
  local -a COMMITS
  mapfile -t COMMITS < <( "${GIT}" log --pretty=oneline "${MERGEBASE}"..HEAD | awk '{print $1}' )
  local -a FILES
  mapfile -t FILES < <( "${GIT}" diff --name-only "${MERGEBASE}"..HEAD )
  _info "PR contains ${#COMMITS[@]} commits, changing ${#FILES[@]} files."

  _confirm_or_exit "About to merge.  Confirm? (y/N)  "
 
  local FROM_BRANCH="${GHUSER}:${CURRENT_BRANCH}"
  if [[ "${UPSTREAM}" == "${GHUSER}" ]]; then
    # gh-cli treats this as a special case for some reason.
    FROM_BRANCH="${CURRENT_BRANCH}"
  fi
  # TODO(jonathan): Instead of using --squash, we should squash locally and
  # then merge.  This will make the later rebase operation cleaner.
  _gh pr merge --squash --repo "${UPSTREAM}/${REPO}" "${FROM_BRANCH}"
  _git fetch upstream

  # Confirm that the merge was successful:
  mapfile -t DIFFS < <( "${GIT}" diff --name-only \
      "upstream/${MAIN}..${CURRENT_BRANCH}" -- "${FILES[@]}" )
  if (( "${#DIFFS[@]}" != 0 )); then
    # TODO(jonathan): should this be a warning?
    _fatal "Uh oh!  Even after merge, these files have local changes:" \
      "  ${DIFFS[*]}"
  fi
   
  # Reset this to be the same as ${MAIN}:
  _git checkout -B "${CURRENT_BRANCH}" "upstream/${MAIN}"
  _git push -u origin "+${CURRENT_BRANCH}"
}

##########################################################################
# remove_branch command
##########################################################################

_register_help "remove_branch" "Remove a branch." "rmbr" <<'EOT'
Usage: gee remove_branch <branch-name>

Removes a branch and it's associated directory.
EOT

function gee__rmbr() { gee__remove_branch "$@"; }
function gee__remove_branch() { 
  local BR="$1";
  if [[ -z "${BR}" ]]; then
    BR="$(_get_current_branch)"
    if [[ -z "${BR}" ]]; then
      _fatal "Must specify a branch name to remove."
    fi
  else
    shift
  fi

  _banner "Deleting ${BR}"
  _checkout_or_die "${BR}"
  _set_main
  local -a  counts=()
  read -r -a counts < <("${GIT}" rev-list --left-right --count "${MAIN}...${BR}")
  if (( counts[1] != 0 )); then
    _warn "Branch \"${BR}\" is ${counts[1]} commit(s) ahead of ${MAIN}."
    _confirm_or_exit "Are you sure you want to force-remove branch ${BR}? (y/N) "
    _info "As you wish."
  fi
  if [[ -n "$("${GIT}" status --porcelain)" ]]; then
    _warn "Branch \"${BR}\" contains uncommitted changes."
    _confirm_or_exit "Are you sure you want to force-remove branch ${BR}? (y/N) "
    _info "Whatever you say, boss."
  fi

  local SHA
  SHA="$("${GIT}" reflog | head -n 1 | awk '{print $1}' )"

  _checkout_or_die "${MAIN}"
  _git worktree remove "${BR}"
  _git branch -D "${BR}"
  if _remote_branch_exists origin "${BR}"; then
    _git_can_fail push origin --delete "${BR}"
  else
    _info "Not deleting remote branch ${BR}: was never created."
  fi

  # Remove branch from parents file, and fix up children's parents.
  _read_parents_file
  local PREV_PARENT
  PREV_PARENT="${PARENTS["${BR}"]}"
  if [[ -z "${PREV_PARENT}" ]]; then PREV_PARENT="${MAIN}"; fi
  unset PARENTS["${BR}"]
  local K
  for K in "${!PARENTS[@]}"; do
    if [[ "${PARENTS["$K"]}" == "${BR}" ]]; then
      PARENTS["$K"]="${PREV_PARENT}"
    fi
  done
  _write_parents_file

  _info "Deleted ${BR}.  To undo: gee make_branch ${BR} ${SHA}"
}

##########################################################################
# fix command
##########################################################################

_register_help "fix" "Run automatic code formatters over changed files only." <<'EOT'
Usage: gee fix

Runs a set of language formatting tools over open files in this branch.

Note: "gee fix" (which fixes code in a branch) is different from "gee repair"
(which checks the gee directory for errors and repairs them).
EOT

function gee__fix() {
  _check_cwd
  local BRANCH
  BRANCH="$(_get_current_branch)"
  local BDIR MERGEBASE B
  _set_main
  MERGEBASE="$(git merge-base "origin/${MAIN}" "${BRANCH}")"
  BDIR="$(_get_branch_rootdir)"
  cd "${BDIR}"

  local -a FILES=()
  local FNAME
  while read -r FNAME; do
    FILES+=( "$(readlink -f "${FNAME}")" )
  done < <( "${GIT}" diff --name-only "${MERGEBASE}" )

  # buildifier:
  local -a BZL_FILES=()
  for FNAME in "${FILES[@]}"; do
    B="$(basename "${FNAME}")"
    if [[ "${B}" =~ \.bzl$|^BUILD|WORKSPACE ]]; then
      BZL_FILES+=( "${FNAME}" )
    fi
  done
  if (( "${#BZL_FILES[@]}" )); then
    _info "buildifier: Fixing ${BZL_FILES[*]}"
    _cmd /usr/bin/bazelisk run \
        --noshow_progress --noshow_loading_progress --logging=0 \
        --ui_event_filters=-info,-debug \
        @com_github_bazelbuild_buildtools//buildifier:buildifier \
        -- \
        -v --add_tables "${BDIR}/bazel/buildifier.tables.json" \
        "${BZL_FILES[@]}"
  fi

  # clang-format:
  local -a CLANG_FILES=()
  for FNAME in "${FILES[@]}"; do
    if [[ "${FNAME}" =~ \.h$|\.c$|\.cc$|\.cpp ]]; then
      CLANG_FILES+=( "${FNAME}" )
    fi
  done
  if (( "${#CLANG_FILES[@]}" )); then
    _info "clang-format: Fixing ${CLANG_FILES[*]}"
    _cmd /usr/bin/clang-format-10 --verbose --style=Google -i "${CLANG_FILES[@]}"
  fi

  # TODO(jonathan): Add more formatters.
}

##########################################################################
# gcd command
##########################################################################
# TODO(jonathan): add an option to make a branch if missing.
# TODO(jonathan): make this work from outside a gee branch.
# TODO(jonathan): add g4d-like functionality such as gcd branch/some/path
#                 and gcd branch@? to find last-edited directory.
# TODO(jonathan): Maybe "change_branch" (chb? cbr? chbr?) is a better name.

_register_help "gcd" "Find the current directory in a different branch." <<'EOT'
Usage: gcd [-b] <branch>

The "-b" option will cause the branch to be created if it doesn't already exist.

The "gcd" command is not meant to be used directly, but is instead designed to
be called from the "gcd" bash function.

To import this function into your environment, add to your .bashrc
file:

    source ~/gee/enkit/master/scripts/gee_aliases.bash

Or for a quick version:

    function gcd() { cd "$(gee gcd "$@")"; }

EOT

function gee__gcd() {
  local BRANCH CURRENT_BRANCH CURRENT_ROOT ABS_PATH REL_PATH OPT_B
  OPT_B=0
  if [[ "$1" == "-b" ]]; then
    OPT_B=1
    shift
  fi
  BRANCH="$1"
  _set_main
  if [[ -z "${BRANCH}" ]]; then
    BRANCH="${MAIN}"
  fi

  if ! _in_gee_branch; then
    cd "${GEE_DIR}/${REPO}/${MAIN}"
  fi
  if ! _in_gee_branch; then
    _die "Can't find ${REPO}/${MAIN} branch.  Something is very wrong here."
  fi

  CURRENT_BRANCH="$(_get_current_branch)"
  if [[ -z "${CURRENT_BRANCH}" ]]; then
    _die "Failed to get name of current branch."
  fi
  CURRENT_ROOT="$(_get_branch_rootdir "${CURRENT_BRANCH}")"
  ABS_PATH="$(readlink -f .)"
  REL_PATH="${ABS_PATH#"${CURRENT_ROOT}"}"
  REL_PATH="${REL_PATH#\/}"

  # check whether BRANCH exists: 
  if ! _local_branch_exists "${BRANCH}"; then
    if (( OPT_B == 1 )); then
      gee__mkbr "${BRANCH}" >&2
      if ! _local_branch_exists "${BRANCH}"; then
        _fatal "Branch \"${REPO}/${BRANCH}\" could not be created."
      fi
    else
      _fatal "Branch \"${REPO}/${BRANCH}\" does not exist.  Make use make_branch?"
    fi
  fi

  local DIR
  _update_branch_to_worktree
  DIR="${BRANCH_TO_WORKTREE["${BRANCH}"]}"
  if [[ -z "${DIR}" ]]; then
    _die "Branch \"${REPO}/${BRANCH}\" exists but isn't in worktree?"
  fi
  if [[ ! -d "${DIR}" ]]; then
    _die "Branch \"${REPO}/${BRANCH}\" exists but ${DIR} is missing."
  fi

  # Trim DIR to the longest path that exists in this branch.
  local P PREV_IFS
  PREV_IFS="${IFS}"
  IFS="/"; for P in ${REL_PATH}; do
    if [[ -d "${DIR}/${P}" ]]; then
      DIR="${DIR}/${P}"
    else
      break
    fi
  done
  PREV_IFS="${IFS}"
  echo "${DIR}"
}

##########################################################################
# hello command
##########################################################################

_register_help "hello" "Check connectivity to github." <<'EOT'
Usage: gee hello

Verifies that the user can communicate with github using ssh.

For more information:
  https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh
EOT

function gee__hello() {
  _get_ghuser_via_ssh
  if [[ -z "${_QUIET}" ]]; then
    _info "Hello, ${GHUSER}.  Connectivity to github is AOK."
  fi
}

##########################################################################
# create_ssh_key command
##########################################################################

_register_help "create_ssh_key" "Create and enroll an ssh key." <<'EOT'
Usage: gee create_ssh_key

This command will attempt to re-enroll you for ssh access to github.

Normally, "gee init" will ensure that you have ssh access.  This command
is only available if something else has gone wrong requiring that keys
be updated.
EOT

function gee__create_ssh_key() {
  _ssh_enroll
  gee__hello
}

##########################################################################
# share command
##########################################################################

_register_help "share" "Share your branch." <<'EOT'
Usage: gee share

Displays URLs that you can paste into emails to share the contents of
your branch with other users (in advance of sending out a PR).
EOT

function gee__share() {
  local CURRENT_BRANCH PARENT_BRANCH
  CURRENT_BRANCH="$(_get_current_branch)"
  PARENT_BRANCH="$(_get_parent_branch)"
  _info "These URLs are useful for sharing:"
  echo  "  https://github.com/${GHUSER}/${REPO}/compare/${PARENT_BRANCH}...${CURRENT_BRANCH}"
  echo  "  https://github.com/${GHUSER}/${REPO}/tree/${CURRENT_BRANCH}"
}

##########################################################################
# repair command
##########################################################################

_register_help "repair" "Repair your gee workspace." <<'EOT'
Usage: gee repair <command>

Gee tries to control some metadata and attempts to file away some of the
sharp edges from git.  Sometimes, bypassing gee to use git directly can
cause some of gee's metadata to become stale.  This command fixes up
any missing or incorrect metadata.
EOT

function gee__repair() {
  # Make sure all tools are available
  _install_tools

  if ! _in_gee_repo; then
    _fatal "Not in a gee repo directory, aborting further repairs."
  fi

  _info "Checking each directory in ${REPO_DIR}..."
  local DIR BRANCH OBRANCH
  for DIR in "${REPO_DIR}"/*; do
    BRANCH="$(basename "${DIR}")"
    cd "${DIR}"
    OBRANCH="$(_get_current_branch)"

    # Give user opportunity to abort in-progress rebase operations:
    if _is_rebase_in_progress; then
      _warn "Rebase in progress on branch ${OBRANCH}"
      mapfile -t STATUS < <( "${GIT}" status );
      _info "${STATUS[@]}"
      if _confirm_default_no "Do you want to abort this rebase operation now?"; then
        _git rebase --abort
        if _is_rebase_in_progress; then
          _die "Error while aborting rebase operation."
        fi
      fi
    fi

    # Make sure the worktree directory points to the right branch:
    if [[ "${OBRANCH}" != "${BRANCH}" ]]; then
      _warn "${BRDIR} pointed to branch ${OBRANCH} instead of ${BRANCH}."
      _git checkout "${BRANCH}"
      _info "... Fixed."
    fi
  done

  _info "Checking each branch in the local repository..."
  local -a ALL_BRANCHES=()
  mapfile -t ALL_BRANCHES < <( "${GIT}" branch --format="%(refname:short)" )
  for BRANCH  in "${ALL_BRANCHES[@]}"; do
    # make sure each branch has a worktree directory:
    _checkout_or_die "${BRANCH}"
  done

  # Repair the PARENT file if it gets corrupted or removed, by attempting to
  # guess the parent for each branch.
  _info "Checking the parents file..."
  _read_parents_file
  local DIRTY=0
  _set_main
  for BRANCH  in "${ALL_BRANCHES[@]}"; do
    if [[ "${BRANCH}" == "${MAIN}" ]]; then continue; fi
    if [[ -z "${PARENTS["${BRANCH}"]}" ]]; then
      _warn "${BRANCH} is missing \"parent\" metadata."
      _checkout_or_die "${BRANCH}"
      # Try to guess which branch is this branch's parent:
      # TODO(jonathan): There is almost certainly a better way using rev-list.
      local PARENT
      PARENT="$(git show-branch | sed "s/].*//" | grep "\*" \
        | grep -v -w "${BRANCH}" | head -n1 \
        | perl -pe 'm/\[([a-zA-Z0-9_-]+?)(\^\d+)?(~\d+)?$/; $_ = $1;' )"
      if [[ -z "${PARENT}" ]]; then
        PARENT="${MAIN}"
      fi
      PARENTS["${BRANCH}"]="${PARENT}"
      DIRTY=1
      _info "Guessed that ${PARENT} is the parent of ${BRANCH}"
    fi
  done
  if (( DIRTY )); then
    _write_parents_file
  fi

  _info "Done."
}

##########################################################################
# bash_setup command
##########################################################################

_register_help "bash_setup" "Configure the bash environment for gee." \
<<'EOT'
Usage: eval "$(enkit gee bash_setup)"

The "bash_setup" command emits a set of bash aliases and functions that
streamline the use of gee.  The following functions are exported:

  "gee": invokes "enkit gee $@"
  "gcd": rapidly change between gee branch directories.
EOT

function gee__bash_setup() {
  cat <<'END_OF_BASH_SETUP'
# bash functions for gee
#
# This output is meant to be loaded into your shell with this command:
#
#   eval "$(enkit gee bash_setup)"

function gee() { 
  if [[ -x ~/bin/gee ]]; then 
    # use locally installed gee if available.
    ~/bin/gee "$@";
  else
    # use the enkit copy of gee.
    enkit gee "$@";
  fi
}

function gcd() {
  if (( "$#" == 0 )); then
    cat <<'EOT'
Usage: gcd <branch-name>

"gcd" changes the current working directory to the same relative directory in
another branch.

For example:

  cd ~/gee/enkit/branch1/foo/bar
  # now in ~/gee/enkit/branch1/foo/bar
  gcd branch2
  # now in ~/gee/enkit/branch2/foo/bar

EOT
    return 1
  fi

  local D="$(gee gcd "$@")"
  if [[ -n "${D}" ]]; then
    cd "${D}"
  fi
}
END_OF_BASH_SETUP
}

##########################################################################
# version command
##########################################################################

_register_help "version" "Print tool version information." <<'EOT'
Usage: gee version
EOT

function gee__version() {
  echo "gee version ${VERSION}"
  sha256sum "$0"
  local TOOL_ERROR=0
  for tool in "${GIT}" "${GH}" "${JQ}"; do
    if ! [[ -x "${tool}" ]]; then
      _warn "${tool}: not installed!"
      TOOL_ERROR=1
    else
      "${tool}" --version
    fi
  done
  if (( TOOL_ERROR )); then
    _info "Run \"gee repair\" to fix."
  fi
}

##########################################################################
# help command
##########################################################################

_register_help "help" "Print more help about a command." <<'EOT'
Usage: gee help <command>
EOT

function gee__help() {
  (
    if (( "$#" == 0 )); then
      set -- "usage"
    fi
    if [[ "$1" == "usage" ]]; then
      echo "${USAGE}" | sed "s/{{VERSION}}/${VERSION}/"
      echo ""
    fi
    if [[ ("$1" == "usage") || ("$1" == "commands") ]]; then
      echo "## Commands:"
      echo ""
      for h in "${HELP[@]}"; do
        echo "  $h"
      done | sort
      shift;
    fi
    while (( "$#" )); do
      local COMMAND="$1"
      shift
      if [ "${LONGHELP[${COMMAND}]+_}" ]; then
        echo "${LONGHELP[${COMMAND}]}"
      else
        echo "${COMMAND}: there is no help for this."
      fi
    done
  ) | "${PAGER}"
}

function gee__banner() {
  _banner "$@"
}

##########################################################################
# main
##########################################################################

function main() {
  if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    shift
    set -- "help" "$@"
  fi
  if (( "$#" == 0 )); then
    gee__help usage
    exit 0
  fi
  local cmdname="$1"; shift
  if type "gee__${cmdname}" >/dev/null 2>&1; then
    _startup_checks
    "gee__${cmdname}" "$@"
    ABNORMAL=0
  else
    echo "Unknown command ${cmdname}"
    echo ""
    gee__help commands
    ABNORMAL=0
    exit 2
  fi
}

main "$@"
