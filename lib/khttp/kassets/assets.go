// Package kassets provides functions and helpers to register static assets typically
// built into your binary with go_embed_data() in an http Mux object.
//
// The assets are minimally pre-processed so, for example:
// - the MIME type is precomputed - once - and always reused.
// - the path of the file is mangled so that modern conventions are followed
//   (file extension from .html file is stripped, for example, and an index.html
//   is used when a directory is requested)
// - files are pre-compressed, so if gzip encoding by the browser is supported,
//   those files are not re-compressed on the fly every time. The pre-compression
//   is dropped if there is not enough saving.
// - ...
//
// The assets preprocessing is configurable by chaining functions together in
// different ways.
package kassets

import (
	"bytes"
	"compress/gzip"
	"mime"
	"net/http"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/enfabrica/enkit/lib/khttp"
	"github.com/enfabrica/enkit/lib/logger"
	"github.com/dustin/go-humanize"
)

// AcceptsEncoding returns true if the "Accept-Encoding" header supplied in the
// accepts parameter supports the encoding specified in the encoding parameter.
//
// The answer is believed to be RFC compliant, but the header parsing in this
// function is not complete: it does the bare minimum necessary to determine if
// the encoding is accepted, or not.
//
// If accepted, true is returned. false otherwise.
func AcceptsEncoding(accepts, encoding string) bool {
	index := strings.Index(accepts, encoding)
	if index < 0 {
		return false
	}

	left := accepts[index+len(encoding):]
	if !strings.HasPrefix(left, ";q=0") {
		return true
	}
	left = left[len(";q=0"):]
	for i := 0; ; i++ {
		if i >= len(left) {
			return true
		}
		if left[i] == '.' {
			continue
		}

		if left[i] < '0' && left[i] > '9' {
			return true
		}
		if left[i] != '0' {
			break
		}
	}
	return false
}

// AssetMapper is a function capable of taking a file name as found in the
// assets (original), the desired name or path to be used on the web server
// (name) together with a handler to be associated with it.
//
// It returns the actual set of paths programmed in the web server.
//
// AssetMappers are designed to be chained together: imagine that a file,
// index.html is to be served in the web server.
//
// The first AssetMapper in the chain may strip the extension (turning
// /path/index.html into /path/index), the second AssettMapper may decide to
// use index.html as a directory index, mapping /path/ to the file, together
// with /path/index (serving the same file) and /path (serving a redirect to
// /path/). This second AssetMapper would invoke child AssetMappers multiple
// times with the original name (/path/index.html) and each one of the names
// listed.
//
// It would then return all the names generated by concatenating the names
// returned by each child AssetMapper, which may in turn mangle, change, drop
// or add additional names.
type AssetMapper func(original, name string, handler khttp.FuncHandler) []string

// MuxMapper returns an AssetMapper that simply returns the specified name
// with an http.ServeMux.
func MuxMapper(mux *http.ServeMux) AssetMapper {
	return func(original, name string, handler khttp.FuncHandler) []string {
		mux.HandleFunc(name, handler)
		return []string{name}
	}
}

<<<<<<< HEAD
type Wrapper func(khttp.FuncHandler) khttp.FuncHandler

// WrapMapper will wrap the computed handler with a handler of your choice.
//
// For example, you can use WrapMapper to wrap the handler for a path behind
// oauth.MakeAuthHandler, or oauth.MakeLoginHandler.
//
// The function you provide (Wrapper) will be invoked and expected to return
// a new handler replacing the originally computed one.
func WrapMapper(wrap Wrapper, mapper AssetMapper) AssetMapper {
	return func(original, name string, handler khttp.FuncHandler) []string {
		return mapper(original, name, wrap(handler))
	}
}

// MapWrapper allows to use different wrappers for different URLs.
//
// For example, you can use MapWrapper to wrap "/index.html" with
// oauth.MakeAuthHandler, while leaving the other pages alone.
//
// The map uses the full "original" name in your assets as the path to
// match against, not the path mangled by other AssetMapper.
//
// Using an empty string "" as a key in the map configures a default
// action for URLs that cannot be otherwise found in the map.
//
// If a match in the map results in nil, the URL is not wrapped with
// any wrapper.
// If neither a match nor a default match can be found, the URL is
// EXCLUDED from further processing - no other AssetMapper is applied.
func MapWrapper(mapping map[string]Wrapper, child AssetMapper) AssetMapper {
	return func(original, name string, handler khttp.FuncHandler) []string {
		wrapper, found := mapping[original]
		if !found {
			wrapper, found = mapping[""]

			if !found {
				return []string{}
			}
		}

		if wrapper != nil {
			handler = wrapper(handler)
		}

		return child(original, name, handler)
	}
}

// BasicMapper returns an AssetMapper to apply simple normalizations to paths.
//
// Specifically:
// - leaves favicon.ico alone.
// - removes the .html extension.
// - maps index.html files to /.
func BasicMapper(mapper AssetMapper) AssetMapper {
	return func(original, name string, handler khttp.FuncHandler) []string {
		if name == "/favicon.ico" {
			return mapper(original, name, handler)
		}

		ext := filepath.Ext(name)
		if ext == ".html" {
			name = strings.TrimSuffix(name, ext)
			res := mapper(original, name, handler)
			if strings.HasSuffix(name, "/index") {
				target := strings.TrimSuffix(name, "index")
				res = append(res, mapper(original, target, handler)...)
			}
			return res
		}

		return mapper(original, name, handler)
	}
}

// PrefixMapper returns an AssetMapper that always prepends a prefix.
func PrefixMapper(prefix string, mapper AssetMapper) AssetMapper {
	return func(original, name string, handler khttp.FuncHandler) []string {
		return mapper(original, path.Join(prefix, name), handler)
	}
}

// StripExtensionMapper returns an AssetMapper to strip all extensions.
func StripExtensionMapper(mapper AssetMapper) AssetMapper {
	return func(original, name string, handler khttp.FuncHandler) []string {
		name = strings.TrimSuffix(name, path.Ext(name))
		return mapper(original, name, handler)
	}
}

// DefaultMapper returns a mapper doing the bare minimum necessary.
func DefaultMapper(mux *http.ServeMux) AssetMapper {
	return BasicMapper(MuxMapper(mux))
}

// AssetResource represents an asset after beign pre-processed.
type AssetResource struct {
	Base string

	Name string
	Mime string

	Size       int
	Compressed int

	Paths []string
}

// AssetStats represents asset statistics useful for debugging.
type AssetStats struct {
	Skipped []AssetResource
	Mapped  []AssetResource

	Total, Compressed     uint64
	JsTotal, JsCompressed uint64
}

func (as *AssetStats) AddSkipped(res AssetResource) {
	if as == nil {
		return
	}
	as.Skipped = append(as.Skipped, res)
}
func (as *AssetStats) AddMapped(res AssetResource) {
	if as == nil {
		return
	}
	as.Mapped = append(as.Mapped, res)
}

func (as *AssetStats) add(ptr *uint64, value int) {
	if as == nil {
		return
	}
	(*ptr) += uint64(value)
}
func (as *AssetStats) AddJsCompressed(size int) {
	as.add(&as.JsCompressed, size)
}
func (as *AssetStats) AddJsTotal(size int) {
	as.add(&as.JsTotal, size)
}

func (as *AssetStats) AddTotal(size int) {
	as.add(&as.Total, size)
}
func (as *AssetStats) AddCompressed(size int) {
	as.add(&as.Compressed, size)
}

// Log will log all statistics collected by an AssetStats object.
func (as AssetStats) Log(p logger.Printer) {
	p("-------------------------------")
	p("Registered assets")

	if len(as.Skipped) > 0 {
		p("  Skipped:")
		for _, res := range as.Skipped {
			base := ""
			if res.Base != "" {
				base = res.Base + ": "
			}
			p("  - %s%s (%s)", base, res.Name, humanize.Bytes(uint64(res.Size)))
		}
	}

	if len(as.Mapped) > 0 {
		p("  Mapped:")
		for _, res := range as.Mapped {
			base := ""
			if res.Base != "" {
				base = res.Base + ": "
			}
			p("  - %s%s - %s - size %s (%s compressed)", base, res.Name, res.Mime, humanize.Bytes(uint64(res.Size)), humanize.Bytes(uint64(res.Compressed)))
			if len(res.Paths) > 1 || (len(res.Paths) == 1 && res.Paths[0] != res.Name) {
				for _, path := range res.Paths {
					if path == res.Name {
						continue
					}

					p("    - re-mapped as %s", path)
				}
			}
		}
	}

	gain := float64(0)
	if as.Total > 0 {
		gain = (100 * float64(as.Compressed)) / float64(as.Total)
	}

	p("-------------------------------")
	p("Total: size %s (compressed: %s)", humanize.Bytes(as.Total), humanize.Bytes(as.Compressed))
	p("Javascript: size %s (compressed: %s)", humanize.Bytes(as.JsTotal), humanize.Bytes(as.JsCompressed))
	p("Mapped: %d, skipped %d - compressed %0.2f%% of total", len(as.Mapped), len(as.Skipped), gain)
	p("-------------------------------")
}

// RegisterAssets goes oever each asset supplied, creates an http handler, and registers it with AssetMapper.
//
// assets is a dict generated via a go_embed_data target, basically a map between a path and byte array
// with the content of the file.
// base is a string determining the top level directory containing the assets, can be empty.
// mapper is a function in charge of mapping the asset and detected handler with the mux.
//
// Example:
// if you set base to be "/data/", assets like "foo/bar/baz/data/test.html" will be mapped
// as "test.html", all that's after "/data/". Files not containing "/data/" will be skipped.
func RegisterAssets(stats *AssetStats, assets map[string][]byte, base string, mapper AssetMapper) {
	now := time.Now()
	for name, data := range assets {
		if base != "" {
			ix := strings.Index(name, base)
			if ix < 0 {
				stats.AddSkipped(AssetResource{Base: base, Name: name, Size: len(data)})
				continue
			}

			name = name[ix+len(base):]
		}

		if len(name) <= 0 {
			stats.AddSkipped(AssetResource{Base: base, Name: name, Size: len(data)})
			continue
		}

		name = path.Clean(name)
		if name[0] != '/' {
			name = "/" + name
		}

		asset := data
		mtype := mime.TypeByExtension(filepath.Ext(name))
		if mtype == "" {
			mtype = "text/plain"
		}

		compressed := &bytes.Buffer{}
		writer := gzip.NewWriter(compressed)
		writer.Write(asset)
		writer.Close()
		clen := len(compressed.Bytes())
		if float32(clen) >= float32(len(asset))*0.98 {
			compressed = nil
			clen = len(asset)
		}

		stats.AddCompressed(clen)
		stats.AddTotal(len(asset))
		// text/javascript; charset=utf-8 is also valid.
		if strings.HasPrefix(mtype, "text/javascript") {
			stats.AddJsCompressed(clen)
			stats.AddJsTotal(len(asset))
		}

		handler := func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", mtype)
			w.Header().Set("Vary", "Accept-Encoding")

			if compressed != nil && AcceptsEncoding(r.Header.Get("Accept-Encoding"), "gzip") {
				w.Header().Set("Content-Encoding", "gzip")
				http.ServeContent(w, r, "", now, bytes.NewReader(compressed.Bytes()))
			} else {
				http.ServeContent(w, r, "", now, bytes.NewReader(asset))
			}
		}

		paths := mapper(name, name, handler)
		stats.AddMapped(AssetResource{Base: base, Name: name, Size: len(asset), Compressed: clen, Mime: mtype, Paths: paths})
	}
}
