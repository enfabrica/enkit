load("//bazel/utils:match.bzl", "matchany")
load("//bazel/utils:labels.bzl", "labelrelative")

def _message(ctx, ofile):
    """Commodity function to format a message with the file paths."""
    return ctx.attr.progress.format(basename = ofile.basename, path = ofile.short_path)

def _run(ctx, ifile, ofile):
    """Commodity function to run a shell command with less typing."""
    ctx.actions.run_shell(
        outputs = [ofile],
        inputs = [ifile],
        tools = ctx.files.tools,
        mnemonic = ctx.attr.mnemonic,
        progress_message = _message(ctx, ofile),
        command = ctx.attr.command,
        env = {
            "input": ifile.path,
            "output": ofile.path,
        },
    )

def _transform(ctx):
    """Implementation for the transform rule."""
    outputs = []
    if ctx.attr.command and not ctx.attr.transform:
        fail(("Target '%s' specifies 'command = ...', but this attribute is ignored when no pattern " +
              " is supplied with the 'transform' attribute") % (ctx.label.name))

    for iattr in ctx.attr.inputs:
        for ifile in iattr.files.to_list():
            opath = labelrelative(iattr.label, ifile.short_path)
            if matchany(opath, ctx.attr.transform, default = False):
                ofile = ctx.actions.declare_file(opath)
                outputs.append(ofile)

                _run(ctx, ifile, ofile)
                continue

            if matchany(opath, ctx.attr.include):
                ofile = ctx.actions.declare_file(opath)
                outputs.append(ofile)

                ctx.actions.symlink(output = ofile, target_file = ifile, progress_message = _message(ctx, ofile))
                continue

    return [DefaultInfo(files = depset(outputs))]

transform = rule(
    doc = """Transforms or filters the files produced by another rule.

Goal of this rule is to apply a transformation and filter all the files
generated by another rule.

Let's say, for example, that you have a rule named 'compile-idl' that
generates a few .h, .cc, and .c files.

Let's say you need to a) replace a string in the .h files, and b) ensure
that the .cc and .h files are provided as input to a rule that compiles
c++ code.

You can use a 'transform' rule to easily achieve that goal:

  transform(
    name = "filtered",
    inputs = [
      ":compile-idl",
    ],
    transform = [
      "*.h",
    ],
    include = [
      "*.cc", "*.h",
    ],
    command = "sed -e 's@IDL_V_1@IDL_DEV@g' < $input > $output",
  )

Now you can have another rule like:

  cc_library(
    ...
    srcs = [
      ":filtered",
    ],
    ...
  )

To build those files, which will only see the .cc and .h files generated.
""",
    implementation = _transform,
    attrs = {
        "inputs": attr.label_list(
            allow_empty = False,
            doc = "Targets whose output files need to be transformed",
        ),
        "include": attr.string_list(
            doc = """Patterns selecting which input files to include in the output.
For each input file, each pattern is checked against the full path of
the file.

If there is at least one match, the input file is included in the
output.
If there is no match, the file is NOT included in the output.

If no include pattern is provided (default), all input files are included
in the output.

Patterns are in a simplified glob format, where only '*' is understood,
and can only appear once in the pattern (eg, *.c, mpi_*, mpi*.c are valid
patterns, mpi_*foo*.c is not valid.
""",
        ),
        "transform": attr.string_list(
            doc = """Patterns selecting which input files need to be transformed.

For each input file, each pattern is checked against the full path of
the file.

If there is at least one match, the command specified in the command
attribute is run with this file as input.
If there is no match, the file is either simply copied, or excluded
from the output, depending on the 'include' attribute.

See the 'include' documentation to learn about valid patterns.
""",
        ),
        "command": attr.string(
            mandatory = False,
            doc = """Command to run for each file matching 'transform'.

The command is run once per file, with $input representing the input
file to transform, and $output the desired output file.
""",
        ),
        "tools": attr.label_list(
            doc = """Additional tools to build to run this command.

If your transform rule requires building a tool from your bazel
tree, specify the tool here. For example, let's say you need
a protocol buffer compiler or an idl-compiler from your tree, you
would need:

  ...
  tools = [
    "//path/to/idl",
  ],
  ...

In your transform target.
""",
        ),
        "mnemonic": attr.string(
            default = "CustomTransform",
            doc = "Passed as 'mnemonic' to the actions run - useful to customize bazel output",
        ),
        "progress": attr.string(
            default = "Transforming {basename}",
            doc = "Passed as progress_message to the actions run - useful to customize basel output",
        ),
    },
)
